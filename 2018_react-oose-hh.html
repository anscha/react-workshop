<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>React Workshop</title>

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">


  <!-- Code syntax highlighting -->
  <!-- <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css"> -->
  <link rel="stylesheet" href="reveal.js/lib/css/github.css">
  <style>
    /*pre code {*/

    /*display: block;*/

    /*padding: 0.5em;*/

    /*background: #FFFFFF !important;*/

    /*color: #000000 !important;*/

    /*}*/

    .right-img {
      margin-left: 10px !important;
      float: right;
      height: 500px;
    }

    .todo:before {
      content: 'TODO: ';
    }

    .todo {
      color: red !important;
    }

    code span.line-number {
      color: lightcoral;
    }

    .reveal pre {
      max-width: 1100px;
    }

    .reveal pre code {
      max-height: 1000px !important;
    }

    .reveal section img {
      border: 0;
      box-shadow: 0 0 0 0
    }

    /*rgb(196, 215, 240)*/

    html.exkurs body {
      background: rgb(252, 220, 185) url("ai/es6-icon.png") no-repeat right bottom;
    }
  </style>

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>

  <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<!--


  Moderne Web-Anwendungen werden immer häufiger als Single-Page-Anwendungen gebaut, die vollständig im Browser laufen, um höchstmöglichen Ansprüchen an UI und UX zu genügen.

Dieses Seminar führt Sie in die Entwicklung von Single-Page-Anwendungen am Beispiel mit React ein. React ist eine JavaScript-Bibliothek die von Facebook entwickelt und als Open-Source-Projekt zur Verfügung gestellt wird. Obwohl React an vielen Stellen mit bestehenden „Best-Practices“ bricht, hat es sich in vielen Projekten und namhaften Websites etabliert.

In diesem Seminar lernen Sie, wie Sie React-Komponenten entwickeln und daraus schließlich eine ganze Anwendung. Sie werden sehen, wie Sie Zugriffe auf eine REST-API machen und 3rd-Party-Bibliotheken in Ihre Anwendung integrieren können.

Außerdem werfen wir einen Blick auf verschiedene Architekturmuster, wie etwa „Flux“ und das Framework „Redux“, mit denen typische Architektur-Probleme bei der Entwicklung von Web-Anwendungen adressiert werden und die auch außerhalb von React Verbreitung finden.

Um Anforderungen wie Langlebigkeit und Wartbarkeit zu genügen, werden wir uns ansehen, wie Sie mit TypeScript auch typsichere Anwendungen mit React bauen können. TypeScript ist eine von Microsoft entwickelte Sprache, die JavaScript unter anderem um ein Typ-System erweitert.

Am Ende des Workshops werden Sie eine Vorstellung davon haben, wie React-Anwendungen aufgebaut sind und was die Stärken und Schwächen von React sind. Die vorgestellten Architekturmuster (und die Sprache TypeScript) lassen sich auch mit anderen JavaScript Frameworks wie Angular oder Vue verwenden.

Zusätzlich zu den Seminarunterlagen erhält jeder Teilnehmer ein Exemplar des Buches „React – Die praktische Einführung in React, React Router und Redux“ von Oliver Zeigermann und Nils Hartmann.

Inhalt
Was sind Single-Page-Anwendungen?
React Grundlagen (inkl. Einführung in ES6)
Architekturmuster: Smart- und Dumb Komponenten
Anbindung einer REST-API
Lebenszyklus von React Komponenten
TypeScript Grundlagen
Typsichere React-Anwendungen mit TypeScript
Statemanagement mit Redux
Voraussetzungen
Dieses Seminar richtet sich an Entwickler und Architekten, die Single-Page-Anwendungen entwickeln wollen. Hierzu werden im Seminar React, JavaScript & TypeScript verwendet. Die im Laufe des Seminars vorgestellten Architekturmuster sowie TypeScript lassen sich allerdings auch mit anderen Web-Frameworks wie z.B. Angular anwenden. Teilnehmer sollten erste Erfahrungen mit der Web-Entwicklung und der Sprache JavaScript haben, am besten von ECMAScript 2015 (ES6).

-->

<body>

  <div class="reveal">
    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
      <section>
        <h3>React Workshop - Vorbereitung</h3>
        <ol style="font-size: 85%">
          <li>
            <ul>
              <li>
                <code>git clone https://github.com/reactbuch/react-workshop.git</code>
              </li>
              <li> oder
                <code>git pull</code>
              </li>
            </ul>
          </li>
          <li>Im geklonten Verzeichnis:
            <code>npm install</code>
            <br>
            <span style="font-size: 85%">(Dafür evtl. einen Proxy konfigurieren
              <a target="_blank" href="http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/">http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/</a>)</span>
          <li>
            <code>npm run start-backend</code>
          </li>
          <li>In neuem Terminal:
            <ul>
              <li>in
                <code>code/workspace</code> wechseln</li>
              <li>Ausführen:
                <code>npm start</code>
              </li>
            </ul>
          </li>
          <li>Browser öffnen:
            <a href="http://localhost:8080" target="_blank">http://localhost:8080</a>
          </li>
          <li>Wenn dort ein Hello-World-Text erscheint ist alles gut
        </ol>
        <p>Folien: Im geklonten Verzeichnis
          <code>2018_react-oose-hh.html</code>

          <br>oder: <a href="https://reactbuch.github.io/react-workshop/2018_react-oose-hh.html#/">https://reactbuch.github.io/react-workshop/2018_react-oose-hh.html</a>
        </p>
      </section>

      <section>
        <h2>
          <b>Webanwendungen entwickeln</b>
        </h2>
        <h3>Single-Page-Anwendungen mit React, Redux und TypeScript</h3>
        <h4>
          <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> /
          <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          /
          <a href="mailto:nils@nilshartmann.net" target="_blank">E-Mail: nils@nilshartmann.net</a>
        </h4>
      </section>


      <section>
        <h2>Inhalt</h2>
        <ul>
          <li>
            <a href="#/t0">Teil 0: React-Einführung und Build-Prozess</a>
          </li>
          <li>
            <a href="#/t1">Teil I: React-Komponenten (Grundlagen)</a>
          </li>
          <li>
            <a href="#/t2">Teil II: React-Komponenten: Details, Hierarchien und Anwendungen</a>
          </li>
          <li>
            <a href="#/t3">Teil III: Daten lesen und schreiben vom Server</a>
          </li>
          <li>
            <a href="#/t4">Teil IV: React Anwendungen mit TypeScript entwickeln</a>
          </li>
          <li>
              <a href="#/t5">Teil V: Testen von React Anwendungen</a>
            </li>
            <li>
                <a href="#/t6">Teil VI: Client-seitiges Routing</a>
              </li>
              <li>
            <a href="#/t7">Teil VII: Externes Statemanagement mit Redux</a>
          </li>
        </ul>
        <div style="font-size:80%">
          <p>
            <b>Jederzeit:</b> Fragen und Diskussionen!</p>
        </div>
      </section>

      <section id="example-app">
        <h2>Beispiel-Anwendung</h2>
        <a target="_blank" href="code/schritte/5-third-party/public/index.html">
          <img src="images/greeting-master-and-detail.png" style="border:0;box-shadow:0 0 0 0;height:650px" />
        </a>
      </section>

      <section id="t0">
        <h1>Teil 0</h1>
        <h2>React-Einführung und Build-Prozess</h2>
      </section>

      <section>
        <h2>Moderne Webanwendungen</h2>
        <div class="fragment">
        <h3 style="font-weight: bold">Aus Benutzersicht: bestes UI/UX</h3>
        <ul>
          <li>Einheitliches Layout und Design</li>
          <li>Konsistenes Verhalten in der ganzen Anwendung</li>
          <li>Konsistente Darstellung der Daten</li>
          <li>Gewohntes Verhalten von Desktop Anwendungen</li>
          <li>Kurze Reaktionszeiten</li>
        </ul>
      </div>

        <div class="fragment">
        <h3 style="font-weight: bold">Aus Entwicklersicht</h3>
        <ul>
          <li>Einfach und schnell</li>
          <li>Saubere und verständliche Architektur</li>
          <li>Wartbar auch bei großer und langlebiger Code-Basis
            </li>
        </ul></div>

      </section>

      <section>
          <h3>Single-Page-Anwendungen</h3>
          <ul>
            <li>Technisch auf einer (index.html)-Seite</li>
            <li>JavaScript ist für Logik und Darstellung alleinverantwortlich</li>
            <li>Back-Button, Deep Links etc trotzdem möglich</li>
            </ul>
        </section>

      <section>
        <h3>Single-Page-Anwendungen</h3>
        <p>Beispiele</p>
        <ul>
          <li><a href="https://outlook.live.com" target="_blank">Microsoft Outlook</a></li>
          <li><a href="https://www.figma.com/" target="_blank">Figma</a></li>
          <li><a href="https://open.spotify.com/browse/featured" target="_blank">Spotify</a></li>
          </ul>
      </section>

      <section>
        <h3>"Klassische" Web Anwendungen</h3>
        <img src="images/abb-02a-classic-webapp-architecture.png" style="border:0;box-shadow:0 0 0 0;height:650px" />
      </section>

      <section>
          <h3>Single-Page-Anwendungen</h3>
          <img src="images/abb-02c-spa-webapp-architecture.png" style="border:0;box-shadow:0 0 0 0;height:650px" />
        </section>

      <section id="react">
        <h2>React</h2>
        <p>
          <a href="https://reactjs.org" target="_blank">https://reactjs.org</a>
        </p>
        <ul>
          <li class="fragment">Framework von und für Facebook</li>
          <li class="fragment">Eingesetzt u.a. von Microsoft, Paypal, Spotify uvm</li>
          <li class="fragment">Minimales API
          <li class="fragment">Minimales Feature Set
            <ul>
              <li>Ihr könnt/müsst viele Entscheidungen selber treffen</li>
            </ul>
          <li class="fragment">Bewusste Verstöße gegen Best-Practices
          <li class="fragment">Zentrales Konzept: <b>Komponenten</b>
        </ul>
      </section>

      <section>
        <h3>Komponenten in React</h3>
        <img src="ai/soc.png">
      </section>

      <section>
        <h3>Komponenten in React</h3>
        <p style="font-size:smaller">Unser Beispiel in Komponenten</p>
        <img src="ai/greeting-example-component-hierarchy.png" style="height: 650px">
      </section>


      <section>
        <h3>React Komponenten</h3>
        <ul>
          <li class="fragment">bestehen aus
            <b>Logik und UI</b>
          <li class="fragment">
            <b>keine Templatesprache</b>
          <li class="fragment">werden
            <b>deklarativ</b> beschrieben
          <li class="fragment">werden immer
            <b>komplett gerendert</b> (kein 2-Wege-Data-Binding)
          <li class="fragment">werden zu
            <b>ganzen Anwendungen</b> aggregiert
        </ul>
      </section>

      <section>
        <h3>React Komponenten</h3>
        <ul class="fragment">
          <li>Werden als ES6 Klasse (oder Funktion) implementiert
          <li>Keine Templatesprache (stattdessen JavaScript)
          <li>Templates können HTML-artige Syntax enthalten (JSX)
        </ul>
      </section>

      <section>
        <h3>Eine erste Komponente: Hello, World!</h3>
        <p><a target="_blank" href="code/schritte/0-hello_world/public/index.html">Demo</a></p>
        <ul class="fragment">
          <li>Beispiel Schritt-für-Schritt (<code>code/workspace-live-coding</code>)</li>
        </ul>

      </section>

      <section>
        <h3>Hello World React</h3>
        <pre><code data-trim contenteditable>
import React from "react";

export default class HelloMessage extends React.Component {

  constructor(props) {
    super(props);

    this.state = {greeting: props.initialGreeting};
  }

  render() {
    return (
      &lt;div>
        &lt;input 
              value={this.state.greeting} 
              onChange=
                {event => this.setState({greeting: event.target.value})}
        />

        &lt;p>{this.state.greeting}, World&lt;/p>

      &lt;/div>
    );
  }
}</code></pre>
      </section>

      <section>
        <h3>Aufruf</h3>
        <div class="fragment">
          <p>
            <code>index.html</code>
          </p>
          <pre><code data-trim contenteditable>
&lt;html>
  &lt;body>
    <div id="mount"></div>
  &lt;/body>
  &lt;script src="dist/main.js">&lt;/script>
&lt;/html>
</code></pre>
        </div>
        <div class="fragment">
          <p>
            <code>main.js</code>
          </p>
          <pre><code data-trim contenteditable class="javascript">
import React from 'react';
import ReactDOM from 'react-dom';

import HelloMessage from './HelloMessage';

const mountNode = document.getElementById('mount');
ReactDOM.render(&lt;HelloMessage initialGreeting="Hello"/>, mountNode);
</code></pre>
        </div>
        <p class="fragment">
          <a target="_blank" href="code/schritte/0-hello_world/public/index.html">Run</a>
        </p>
      </section>

      <section data-state="exkurs">
        <h3>Hintergrund</h3>
        <h2>ES6 Features</h2>
      </section>

      <section data-state="exkurs">
        <h3>ES6: Klassen</h3>
        <pre><code class="javascript" contenteditable>class Person {
    constructor(name) {
        this._name = name;
    }
    getName() {
        return this._name;
    }
}
class Programmer extends Person {
    constructor(name, language) {
        super(name);
        this.language = language;
    }
    code() {
        return `${this.getName()} codes in ${this.language}`;
    }
}</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>const programmer = new Programmer('Erna', 'JavaScript');
console.log(programmer.code());
console.log(programmer instanceof Programmer); // true
console.log(programmer instanceof Person); // true</code></pre>
      </section>
      <section data-state="exkurs">
        <h2>ES6: Module, Importe und Exporte</h2>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Export einer einzigen Klasse</h3>
        <pre><code class="javascript" contenteditable>// Person.js
  class Person {
    // ...
  }
  export default Person;
     </code></pre>
        <pre><code class="javascript" contenteditable>// Person.js
  
  // in einer Zeile zusammengefasst
  export default class Person {
    // ...
  }
     </code></pre>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Import</h3>
        <pre><code class="javascript" contenteditable>// Programmer.js
  import Person from './Person';
  
  export default class Programmer extends Person {
    // ...
  }
     </code></pre>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Benannte Exporte</h3>
        <pre><code class="javascript" contenteditable data-trim>// util.js
  export function displayInPage(text) {
      document.body.innerHTML +=
          `${text}<br>` ;
  }
  
  export showInfo = msg => window.alert(`Wichtige Info: ${msg}`);
  
  // or
  function displayInPage(text) { . . . }
  
  const showInfo = ...;
  
  // specify exports
  export { displayInPage, showInfo };
     </code></pre>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage} from "./util";
  displayInPage('Hello, World');
     </code></pre>
        <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage as display} from "./util";-->
        <!--display('Hello, World');-->
        <!--</code></pre>-->
        <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import * as util from "./util";-->
        <!--util.displayInPage('Hello, World');-->
        <!--</code></pre>-->
      </section>
      <section data-state="exkurs">
        <h3>ES6: Arrow Functions</h3>
        <pre><code class="javascript" contenteditable>const displayInPage = (text) => {
   return document.body.innerHTML +=
       `${text}<br>`;
};</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>// Klammern können weggelassen werden, genau ein Parameter
// ebenso die geschweiften Klassen, wenn nur ein Statement:
const displayInPage = text => document.body.innerHTML += `${text}<br>`;
</code></pre>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Template Strings</h3>
        <p>Template Strings werden in Backticks (``) geschrieben und können Ausdrücke (in
          <code>${}</code>) enthalten:</p>

        <pre><code class="javascript" contenteditable>const name = "Susi";
const greeting = `Hello, ${name}`; // Hello, Susi

const four = `Two and two is: ${2+2}` // Two and two is: 4

const time = `The time is: ${new Date()}`); // The time is: ...
            </code></pre>
      </section>


      <section>
        <h2>Hintergrund</h2>
        <h1>Buildprozess</h1>
      </section>


      <section>
        <h2>Buildprozess</h2>
        <ul>
          <li>ES6ff- und JSX-Code muss nach ECMAScript 5 übersetzt werden
            <ul>
              <li>Status der ES6 Implementierungen der Browser:
                <a href="https://kangax.github.io/compat-table/es6/" target="blank">
                  https://kangax.github.io/compat-table/es6/
                </a>
              </li>
            </ul>
          <li class="fragment">Typische Werkzeuge
            <ul>
              <li>Babel oder TypeScript (Compiler)
              <li>Webpack (Bundler)
              <li>Webpack Dev Sever (HTTP Server mit Hot Reload)
            </ul>
        </ul>
      </section>
      <section>
        <h2>Webpack und Babel</h2>
        <img src="images/webpack-und-babel.png" style="border:0;box-shadow:0 0 0 0" />
      </section>
      <section>
        <h2>Webpack Development Server</h2>
        <ul>
          <li>Zum Ausführen der Anwendung wird ein Webserver benötigt</li>
          <li class="fragment">Für die Entwicklung
            <b>Webpack Dev Server</b>:
            <ul>
              <li>...führt Webpack auf Basis der Projekt Webpack Konfiguration aus</li>
              <li>...erzeugt Ausgabe in Memory (Performance)</li>
              <li>...Hot Reloading: Automatische Aktualisierung nach Code Änderung</li>
              <li>...React Hot Loader: Zustand bleibt nach Aktualisierung erhalten (Beta)</li>
            </ul>
        </ul>
      </section>
      <section>
        <h3>create-react-app</h3>
        <a href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents"
          target="_blank">User Guide</a>
        <p>Bootstrap von React Anwendung</p>
        <p>Fertige Konfiguration von Webpack, React, ...</p>
        <p>Beispiel: npx create-react-app PROJEKTNAME --typescript</p>
      </section>
      <section>
        <h3>Der yarn Package Manager</h3>
        <a href="https://yarnpkg.com/" target="_blank">https://yarnpkg.com</a>
        <p class="fragment">Alternative zu NPM</p>
        <p class="fragment">Verwendet ebenfalls package.json</p>
        <span class="fragment">
          <p>Etwas anderes Kommandozeileninterface:</p>
          <pre><code data-trim contenteditable class="bash">
# Installiert alle Pakete aus der package.json
yarn
# oder:
yarn install

# Neues Paket installieren oder aktualiseren
yarn add [--dev] package  

# Script aus package.json Ausführen
yarn SCRIPT_NAME
        </code>
          </pre>
        </span>

      </section>
      <section>
        <h3>Das Beispiel-Project</h3>
        <p>Workspace</p>
        <ul>
          <li>
            <code>2018_react-oose-hh.html</code> Slides im Root-Verzeichnis</li>
          <li>
            <code>code/workspace</code>: Verzeichnis für Eure Übungen</li>
          <li>
            <code>code/schritte</code>: Fertige Stände nach den einzelnen Teilen</li>
          <li>
            <code>code/material</code>: Code als Ausgangspunkt für Übungen</li>
        </ul>
        <p>Starten</p>
        <ol>
          <li>Im
            <b>Root-Verzeichnis (falls noch nicht geschehen)</b>:
            <code>npm run start-backend</code>, um den REST-Server zustarten (einmal starten, dann einfach durchlaufen
            lassen)</li>
          <li>In
            <b>code/workspace</b>:
            <code>npm start</code>, um Webpack DevServer zu starten. Kann durchlaufen, falls Reload nicht klappt, neu
            starten</li>
        </ol>
      </section>
      <section>
        <h2>Übung 0: React Hello-World</h2>
        <h3>Mach dich mit den Werkzeugen vertraut und schreib deine erste React-Komponente</h3>
      </section>
      <section>
        <h3>Schritt #1: Tool-Chain starten (falls noch nicht gemacht)</h3>
        <p>Nutze für die Übungen das
          <code>workspace</code>-Verzeichnis in diesem Repository. Hier ist eine Tool-Chain mit Webpack und Babel
          vorbereitet</p>
        <ol style="font-size: 85%">
          <li>
            <code>npm install</code> (auf oberster Ebene)
            <br>
            <span style="font-size: 85%">(Dafür evtl. einen Proxy konfigurieren
              <a target="_blank" href="http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/">http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/</a>)</span>
          <li>
            <code>cd code/workspace</code>
          <li>
            <code>npm start</code>
          <li>Öffne
            <a href="http://localhost:8080" target="_blank">http://localhost:8080</a> im Browser
          <li>Wenn auf der Seite 'Hello, World' steht, ist alles gut
        </ol>
      </section>
      <section>
        <h3>Schritt #2: Deine erste React-Komponente</h3>
        <ul>
          <li>Ersetze die "statische" Komponente (HelloMessage) mit der React-Komponente aus dem vorherigen Beispiel
            aus den
            Folien
          <li>
            <em>Zusatzaufgabe: Experimentiere mit der Anwendung, mache einige Änderungen, wie z.B.</em>
            <ul>
              <li>Alle Eingaben sollen in Großbuchstaben auftauchen
              <li>Gib irgendeine Rückmeldung wenn die Eingabe leer ist
            </ul>
          </li>
        </ul>
      </section>

      <section id="t1">
        <h1>Teil I</h1>
        <h2>React-Komponenten (Grundlagen)</h2>
        <a href="code/schritte/1-detail/public/index.html" target="_blank">Ziel-Anwendung</a>
      </section>

      <section>
        <h2>Dokumentation</h2>
        <p>
          <a href="https://reactjs.org/docs/hello-world.html" target="_blank">
            https://reactjs.org/docs/hello-world.html
          </a>
        </p>
      </section>


      <section>
        <h3>Themen</h3>
        <ul>
          <li>Rendering
          <li>Properties und Zustand
          <li>Referenzen auf DOM-Elemente (Refs)
        </ul>
      </section>

      <section>
        <h3>React: Rendering</h3>
        <span class="fragment">
          <p>
            <em>Jede React-Komponente braucht eine
              <code>render</code>-Methode:</em>
            <ul>
              <li>wird aufgerufen beim ersten Rendering und wenn sich der Zustand ändert</li>
              <li>kann HTML-artige JSX-Syntax nutzen</li>
              <li>liefert genau
                <b>ein</b> Element oder
                <b>null</b> oder
                <b>ein Boolean</b> oder
                <b>ein Array</b> oder
                <b>ein Fragment</b> oder
                <b>einen String</b> zurück</li>
            </ul>
            <pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
      <div>
        &lt;input onChange={event => this.updateModel(event.target.value)}
           value={this.state.greeting} />
        <p>{this.state.greeting}, World</p>
      </div>
    );
  }
  // ...
}
</code></pre>
        </span>
      </section>
      <section>
        <h3>React: JSX</h3>
        <ul>
          <li style="font-size: 80%" class="fragment">Wird wie HTML hingeschrieben, inkl Attribute:
            <pre><code class="xml" contenteditable data-trim>
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">Attribute, die keine Strings sind, müssen in {} eingeschlossen
            werden:
            <pre><code class="xml" contenteditable data-trim>
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">Kann pures JavaScript enthalten, eingeschlossen in {}:
            <pre><code class="xml" contenteditable data-trim>
const title = 'Hello, World';
&lt;h1>{title.toUpperCase()}&lt;/h1>
                    </code></pre>
          </li>

          <li style="font-size: 80%" class="fragment">
            <code>class</code>-Attribut heißt
            <code>className</code>:
            <pre><code class="xml" contenteditable data-trim>
                        &lt;h1 className="title">...&lt;/h1>
                    </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">CSS-Eigenschaften werden als Objekt übergeben in
            Camel-Case-Notation:
            <pre><code class="xml" contenteditable data-trim>
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
          </li>
        </ul>
      </section>
      <section>
        <h3>React: JSX #2</h3>
        <ul>
          <li style="font-size: 80%" class="fragment">Zuweisen an Variablen
            <pre><code class="xml" contenteditable data-trim>
const counter = &lt;Counter label="..." />
                    </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">...als Return-Wert:
            <pre><code class="xml" contenteditable data-trim>
function renderCounter(label) { return &lt;Counter label="..." />; }
                      </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">Fragmente (rendern selber kein Element in den DOM, nur ihre
            Kind-Elemente):
            <pre><code class="xml" contenteditable data-trim>
render() { 
  return &lt;React.Fragment&gt;
    &lt;li>Yes&lt;/li> 
    &lt;li>No&lt;/li>
  &lt/React.Fragment>              
}  
                    </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">null, false oder boolean, um nichts zu rendern:
            <pre><code class="xml" contenteditable data-trim>
render() {
  if (!someCondition) {
    return null; // oder false oder true
  }

  return ...;
}              
                    </code></pre>
          </li>

        </ul>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Erweiterte Objekt-Literale</h3>
        <pre><code class="javascript" contenteditable>

// ES5:
const firstName = 'Klaus';
const person = {
    firstName: firstName
};
console.log(person.firstName); // Klaus

// ES6:
const firstName = 'Klaus';
const person = {
    firstName
};
console.log(person.firstName); // Klaus
   </code></pre>
      </section>



      <!--<section>-->
      <!--<h2>Neuerungen und Verbesserungen in ES6</h2>-->
      <!--</section>-->

      <!--<section>-->
      <!--<h3>Tagged Template Literals</h3>-->
      <!--<p><a target="_blank" href="http://exploringjs.com/es6/ch_template-literals.html#_tagged-templates">-->
      <!--Mini-DSLs: Template-Literals mit tag-->
      <!--</a>-->
      <!--</p>-->

      <!--<pre class="fragment"><code class="javascript" contenteditable>function tag(strings, ...values) {-->
      <!--console.log(strings);-->
      <!--//[ '', ' codes in ', '.' ]-->
      <!--console.log(values);-->
      <!--//[ 'Oma', 'Haskell' ]-->
      <!--return 'whatever you want';-->
      <!--}-->
      <!--</code></pre>-->

      <!--<pre><code class="javascript" contenteditable>const expanded = tag`${person} codes in ${language}.`;-->
      <!--console.log(expanded);-->
      <!--//whatever you want-->
      <!--</code></pre>-->

      <!--</section>-->

      <section data-state="exkurs">
        <h3>ES6: Destructuring von Objekten</h3>
        <pre><code class="javascript" contenteditable>const person = {
  fistName: 'Klaus',
  lastName: 'Mueller',
  age: 42
};</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>const {firstName, age, notThere} = person;

console.log(firstName); // Klaus
console.log(age); // 42
console.log(notThere); // undefined
</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>function someFunction({firstName, age, notThere}) {
  console.log(firstName); // Klaus
  console.log(age); // 42
  console.log(notThere); // undefined
}

someFunction(person);
</code></pre>
      </section>
      <section>
        <h3>React: Properties und Zustand</h3>
        <ul class="fragment">
          <li>
            <b>Properties</b> werden der Komponente von
            <b>außen</b> übergeben (und nicht verändert)</li>
          <li>
            <b>Zustand (State)</b> ist eine
            <b>innere</b> Eigenschaft der Komponente (die verändert werden kann)</li>
          <li>Beides sind Objekte mit Key-Value-Paaren</li>
        </ul>
      </section>

      <section>
        <h3>Properties einer Komponente</h3>
        <ul class="fragment">
          <li>Properties werden über den Konstruktor in die Komponente hineingereicht</li>
          <li>Properties dürfen nicht verändert werden</li>
          <li>Zugriff über
            <code>this.props</code>
          </li>
        </ul>
      </section>
      <section>
          <h3>Children einer Komponente</h3>
          <ul class="fragment">
              <code>this.props.children</code> enthält Kind-Elemente</li>
          </ul>
          <div class="fragment">Beispiel:
          <pre><code class="javascript" contenteditable data-trim>
  class NavBar extends React.Component {
    render() {
      return (
        &lt;div className="NavBar">
          <h1>{this.props.title}</h1>
         
          {this.props.children}
        &lt;/div>
      );
    }
  }
  </code></pre></div><div class="fragment">Verwendung:
          <pre><code class="javascript" contenteditable data-trim>
    &lt;NavBar title="Navigation">
      &lt;a href="/home">Home&lt;/a&gt;
      &lt;a href="/shop">Shop&lt;/a&gt;
    &lt;/NavBar>
  </code></pre>
</div>
        </section>
      <section>
        <h3>Zustand einer Komponente</h3>
        <ul class="fragment">
          <li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server, Menu offen oder zu</li>
          <li>
            <b>Werte</b> üblicherweise immutable</li>
          <li class="fragment">
            <b>Initialisieren</b> im Konstruktor mit
            <code>this.state={}</code>
          <li class="fragment">Zustand
            <b>lesen</b> über
            <code>this.state</code>
          <li class="fragment">Zustand
            <b>setzen</b> über
            <code>this.setState()</code>
            <ul class="fragment">
              <li>
                <b>Achtung:</b> kein "reiner" Setter</li>
              <li class="fragment">Führt alten und neuen Zustand zusammen</li>
              <li class="fragment">Wird asynchron ausgeführt!</li>
              <li class="fragment">
                <b>Löst erneutes rendern der
                  <i>gesamten</i> Komponente aus</b>
              </li>
            </ul>
          <li class="fragment">Eines der <b>zentralen</b> Konzepte von React</li>
        </ul>
      </section>

      <section>
        <h3>Beispiel: Zustand einer Komponente</h3>
        <pre><code class="javascript" contenteditable data-trim>
class GreetingDetail extends React.Component {
    constructor(props) {
        super(props);
        this.state = { name: 'Klaus' };
    }

    updateModel(event) {
        // Zustand ändern: Komponente wird neu gerendert
        this.setState({name: event.target.value});
    }

    render() {
        return &lt;input value={this.state.name}
            onChange={e => this.updateModel(e)} />
    }
   // ...
}
</code></pre>
      </section>
      <section>
        <h3>React: Events und Data Binding</h3>
        <p>
          <em>Es gibt keine automatische Bindung an Modelle (2-Wege Databinding)</em>
        </p>
        <ul class="fragment">
          <li>DOM-Events werden in React-Events verpackt
          <li>React-Events haben weitgehend selbe API wie DOM-Events
          <li>Besonderes Event:
            <b>onChange</b>
            <ul>
              <li>onChange ist auf
                <code>input</code>,
                <code>textarea</code>,
                <code>select</code> definiert und verhält sich Komponenten- und Browser-übergreifend einheitlich
              </li>
            </ul>
          </li>
        </ul>
        <pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
        &lt;input onChange={event => . . .} />
    );
  }
  // ...
}
</code></pre>
      </section>

      <section>
        <h3>Render Zyklus</h3>
        <img src="images/event-zustand-render.png" height="550" style="border:0;box-shadow:0 0 0 0">
      </section>

      <section>
        <h3>Virtual DOM</h3>
        <p>"Rendern" hat doppelte Bedeutung!</p>
        <img src="images/virtual-dom.png" style="border:0;box-shadow:0 0 0 0;height:650px">
      </section>

      <section>
        <h3>React: Referenzen auf nativen DOM</h3>
        <ul class="fragment">
          <li>Elementen kann eine Callback-Funktion
            <code>refs</code> übergeben werden
          <li class="fragment">Funktion wird nach dem Rendern mit Referenz auf DOM Element aufgerufen (oder
            <code>null</code>)
          <li class="fragment">Diese Referenz kann man z.B. als Member-Variable speichern
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
class HelloMessage extends React.Component {
  render() {
    return (
      <div>
        &lt;input ref={inputElement => this.inputElement = inputElement} 
                  onChange={...} value={...}
        />
        &lt;button
          onClick={() => this.reset()}>
            Clear
        &lt;/button>
      </div>
    );
  }

  reset() {
    this.setState({greeting: ""});

    // focus() ist Funktion auf nativem DOM Element
    this.inputElement.focus();
  }
}
</code></pre>
      </section>

      <section>
        <h3>Properties, State und Instanz-Variablen</h3>
        <ul>
          <li class="fragment">
            <b>Properties</b>: Konfiguration von außen übergeben. Unveränderlich innerhalb der Komponente</li>
          <li class="fragment">
            <b>State:
            </b>: Interner und veränderlicher Zustand der Komponente. State-Änderung führt zu re-rendering
          </li>
          <li class="fragment">
            <b>Instanz-Variablen</b>: Nicht render-relevante Informationen, zB Refernzen auf DOM-Elemente, Callbacks
            zum Beenden
            von Timern</li>
        </ul>
      </section>

      <section>
        <h2>Übung 1: Detail-Ansicht für unsere Gruß-Anwendung</h2>
        <h3>Erzeuge eine Komponente mit der man einen Namen und eine Grußformel eingeben kann</h3>
      </section>
      <section>
        <h3>Schritte</h3>
        <h4>Erweitere deine erste React-Komponente im workspace-Ordner</h4>
        <ul>
          <li>benenne deine Komponente in
            <code>GreetingDetail</code> um
          <li>du brauchst zwei Eingabefelder, die
            <code>name</code> und
            <code>greeting</code> im Zustand der Komponente setzen
          <li>Erweitere deine Komponente so, dass man von außen Properties übergeben kann, die den Zustand
            initialisieren
          <li>Optionaler Schritt: Kannst du die Komponente so bauen, dass du mit einer einzigen update-Methode beide
            Felder
            im Zustand updaten kannst?
        </ul>
      </section>

      <section id="t2">
        <h1>Teil II</h1>
        <h2>React-Komponenten: Details, Hierarchien und Anwendungen</h2>
        <a href="code/schritte/2-hierarchy/public/index.html" target="_blank">Ziel-Anwendung</a>
      </section>

      <section>
        <h3>Themen</h3>
        <ul>
          <li>Komponenten als Funktionen</li>
          <li>PropTypes</li>
          <li>Darstellung von Listen</li>
          <li>Architektur-Idee: Controller-Komponente und View-Komponente</li>
          <li>Durchreichen von Zustand und Callbacks</li>
        </ul>
      </section>


      <section>
        <h3>Komponenten als Funktion</h3>
        <ul class="fragment">
          <li>Alternative zu Klassen</li>
          <li>Komponente ist eine einfache Funktion</li>
          <li>entspricht der
            <code>render</code>-Methode einer
            <code>React.Component</code>
          <li>Properties werden per Parameter übergeben (als Objekt)</li>
          <li>Zurzeit nur ohne Zustand und ohne Lifecycle-Methoden</li>
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
import React from 'react';

export default function Greet(props) {
  return (
      <div>
          <h1>{props.greeting}</h1>
          <h2>{props.name}</h2>
      </div>
  );
}

// Verwendung:
&lt;Greet name="Susi" greeting="Hello" /&gt;

</code></pre>
      </section>
      <section>
        <h3>Komponenten als Funktion</h3>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Mit Destructuring
export default function Greet({greeting, name}) {
  return (
      &lt;div>
          &lt;h1>{greeting}&lt;/h1>
          &lt;h2>{name}&lt;/h2>
      &lt;/div>
  );
}
</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Als Arrow Function
const Greet = ({greeting, name}) => (
  &lt;div>
    &lt;h1>{greeting}&lt;/h1>
    &lt;h2>{name}&lt;/h2>
  &lt;/div>
);

export default Greet;
</code></pre>

      </section>
      <section>
        <h3>PropTypes</h3>
        <ul class="fragment">
          <li>Eine Komponente kann deklarieren, welche Properties sie erwartet
          <li>Auch der Typ kann angegeben werden (
            <a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank">Mögliche
              Typen</a>)
          <li>Fehlende / falsche Properties führen zu Laufzeitfehlern
          <li>Ab React 15.5 eigenes npm modul:
            <a href="https://www.npmjs.com/package/prop-types" target="_blank">
              <code>prop-types</code>
            </a>
          </li>
          <li>Alternative: Typsystem (
            <a href="https://flow.org" target="_blank">Flow</a> oder
            <a href="https://typescriptlang.org" target="_blank">TypeScript</a>)
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
  import PropTypes from 'prop-types';
  
  class GreetingDetail extends React.Component { . . . };
  
  GreetingDetail.propTypes = {
      greeting: PropTypes.shape({
        name: PropTypes.string.isRequired,
        greeting: PropTypes.string.isRequired
      }),
      onAdd: PropTypes.func.isRequired
  };
  </code></pre>
      </section>
      <section>
        <h3>PropTypes</h3>
        <p>Mit statischen Properties (
          <code>static</code> noch kein JS Standard!)</p>
        <pre><code class="javascript" contenteditable data-trim>
  import PropTypes from 'prop-types';
  
  class GreetingDetail extends React.Component {
    static propTypes = {
      greeting: PropTypes.shape({
        name: PropTypes.string.isRequired,
        greeting: PropTypes.string.isRequired
      }),
      onAdd: PropTypes.func.isRequired
    };
  
    render() { . . . }
  };
              </code></pre>
      </section>
      <section>
        <h3>PropTypes</h3>
        <p>Für Komponenten als Funktionen</p>
        <pre><code class="javascript" contenteditable data-trim>
  import PropTypes from 'prop-types';
  
  function HelloMessage(text) { . . . }
  
  HelloMessage.propTypes = {
    text: PropTypes.string.isRequired
  }
              </code></pre>
      </section>

      <section>
        <div style="display: flex">
          <div style="flex: 1">
            <img src="images/greeting-master-table.png" style="max-width:100%" />
          </div>
          <div style="flex: 1">
            <h3>Listen</h3>
            <div class="fragment" style="display: flex; flex-direction: column; justify-content: center;align-items: center">
              <p>JSX bietet nichts für Listen</p>
              <p>Ausgabe typischerweise über
                <code>Array.map()</code>
              </p>
              <p>Elemente einer Liste brauchen einen eindeutigen Key</p>


              <pre class="fragment"><code class="javascript" contenteditable data-trim>
const greetings = [
  { id: 0, name: 'Olli', greeting: 'Huhu' },
  { id: 1, name: 'Oma', greeting: 'Hallo' }
];

const MyTable(props) => (
    &lt;table>
      {props.greetings.map(greeting =>
        &lt;tr key={greeting.id}>
            &lt;td>{greeting.name}&lt;/td>
            &lt;td>{greeting.greeting}&lt;/td>
        &lt;/tr>
      )}
    &lt;/table>
);
</code></pre>
            </div>
          </div>
        </div>
      </section>
      <section>
        <h3>Listen und Keys</h3>
        <ul class="fragment">
          <li>Ab React 16 können Arrays in
            <code>render</code> zurückgegeben werden (anstatt
            <b>eines</b> Root Elements)
          <li>Elemente brauchen trotzdem einen eindeutigen Key
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Beispiel: statische Elemente          
const Choices = () => { 
  return [
    &lt;td key="yes">Yes&lt;/td>,
    &lt;td key="no">No&lt;/td>
  ]
};
          </code></pre>

        <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Beispiel: dynamisches Array          
const GreetingRows = ({greetings}) => {

  // map liefert ein Array zurück!
  return greetings.map(greeting =>
    &lt;tr key={greeting.id}>
      &lt;td>{greeting.name}&lt;/td>
      &lt;td>{greeting.greeting}&lt;/td>
    &lt;/tr>
  ;
)
</code></pre>
      </section>
      <section>
        <h3>Fragmente</h3>
        <ul style="font-size:90%">
          <li class="fragment">Eine React-Komponente liefert immer genau
            <b>ein</b> (Top-Level)-Element zurück</li>
          <li class="fragment">Alternative 1: Arrays (wie gesehen)</li>
          <li class="fragment">Alternative 2: Fragments</li>
          <li class="fragment">Ein Fragment ist ein Top-Level-Element, für das kein DOM-Element erzeugt wird (ab React
            16.2)</li>
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim style="font-size:70%">
// geht nicht:          
const Choices = () => ( 
  &lt;td key="yes">Yes&lt;/td>
  &lt;td key="no">No&lt;/td>
);

// geht:          
const Choices = () => ( 
  &lt;React.Fragment>
    &lt;td key="yes">Yes&lt;/td>
    &lt;td key="no">No&lt;/td>
  &lt;/React.Fragment>  
);

// alternativ:
const Choices = () => (
  &lt;>
    &lt;td key="yes">Yes&lt;/td>
    &lt;td key="no">No&lt;/td>
  &lt;/>
);

            </code></pre>
      </section>
      <section>
        <h2>Anwendungen und Komponentenhierarchien</h2>
      </section>
      <section>
        <h3>Problem: Kommunikation zwischen Komponenten</h3>
        <p>#1: Welche Komponente soll angezeigt werden (Master oder Detail?)</p>
        <img src="ai/component-hierarchy-problems-01-views.png" style="height:550px" />
      </section>
      <section>
        <h3>Problem: Kommunikation zwischen Komponenten</h3>
        <p>#2: Wo wird der State (Greetings) verwaltet?</p>
        <img src="ai/component-hierarchy-problems-02-greeting.png" style="height:550px" />
      </section>
      <section>
        <h3>Problem #1</h3>
        <h2>Welche Komponente soll angezeigt werden?</h2>
        <p>Master oder Detail?</p>
        <p>Schritt-für-Schritt in <code>code/workspace-live-coding</code></p>
      </section>
      <section>
        <h3>Controller Komponente #1</h3>
        <p>Verwaltet den Zustand (u.a. welche Komponente sichtbar ist)</p>
        <img src="ai/greeting-hierarchy-mode.png" style="height:550px" />
      </section>
      <section>
        <h3>Controller Komponente #2</h3>
        <p>Rendering der Children</p>
        <pre><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {
  constructor() {
    this.state = { mode: 'MASTER' }
  }

  render() {
    if (this.state.mode === 'MASTER') {
      return &lt;GreetingMaster />;
    } 
    return &lt;GreetingDetail />;
  }
}            
            </code></pre>
      </section>

      <section>
        <h3>Controller Komponente</h3>
        <p class="fragment">Wie wird zwischen den Komponenten kommuniziert?</p>
        <p class="fragment">Beispiel: Child-Komponente will Parent Informationen übermitteln</p>
        <p class="fragment">Callback-Funktionen als Properties #1</p>
        <img class="fragment" src="ai/greeting-hierarchy-mode-callback.png" style="height:550px" />
      </section>

      <section>
        <h3>Controller Komponente</h3>
        <p>Kommunikation mit Children: Callback-Funktionen als Properties #2</p>
        <pre><code class="javascript" contenteditable data-trim>
  class GreetingController extends React.Component {
    constructor() { . . . }
  
    render() {
      if (this.state.mode === 'MASTER') {
        return &lt;GreetingMaster 
          onAdd={() => this.setState({mode: 'DETAIL'}) } />;
      } 
      return &lt;GreetingDetail 
          onSave={() => this.setState({mode: 'MASTER'}) } />;
    }
  }      
</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
  class GreetingMaster extends React.Component {
    render() {
      return (
        ...
        &lt;button onClick={this.props.onAdd}>Add&lt;/button>
      )
    }
  }            
              </code></pre>
      </section>

      <section>
        <h3>Problem #2</h3>
        <h2>Wo wird der State (Greetings) verwaltet?</h2>
        <p>Wie kommen neue Greetings (GreetingDetail) in die Liste (GreetingMaster)?</p>
      </section>
      <section>
        <h3>Controller Komponente</h3>
        <p class="fragment">Verwaltet den "globalen" State</p>
        <p class="fragment">State wird als Property an Children übergeben</p>
        <img class="fragment" src="ai/greeting-hierarchy-greetings.png" style="height:550px" />
      </section>
      <section>
        <h3>Controller Komponente</h3>
        <p>State wird als Property an Children übergeben #2</p>
        <pre><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {
  constructor() { 
    this.state = {
      mode: 'MASTER',
      greetings: . . .
    }        
  }  
    
  render() {
    if (this.state.mode === 'MASTER') {
      return &lt;GreetingMaster
        greetings={this.state.greetings} 
        onAdd={() => this.setState({mode: 'DETAIL'}) } 
      />;
    }
    . . . 
  }
}      
  </code></pre>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingMaster extends React.Component {
  render() {
    const greetings = this.props.greetings;
    return (
      &lt;table>
        { greetings.map(g => &lt;tr>...&lt;/tr>) }
      &lt;/table>
      &lt;button onClick={this.props.onAdd}>Add&lt;/button>
    )
  }
}            
                </code></pre>
      </section>
      <section>
        <h3>Controller Komponente</h3>
        <p class="fragment">Verwaltet den "globalen" State</p>
        <div class="fragment">
          <span style="color: #9D4493">Neues Greeting</span> wird per Callback-Funktion zurück gegeben
          <img src="ai/greeting-hierarchy-onsave.png" style="height:550px" />
        </div>
      </section>
      <section>
        <h3>Controller Komponente</h3>
        <p>Neues Greeting wird per Callback-Funktion übergeben #2</p>
        <pre><code class="javascript" contenteditable data-trim>
  class GreetingController extends React.Component {
    constructor() { . . . }
      
    render() {
      if (this.state.mode === 'MASTER') {
        . . .
      }
      return &lt;GreetingDetail 
        onSave={(newGreeting) => this.setState({
          greetings: [...this.state.greetings, newGreeting],
          mode: 'MASTER'}) 
        } 
      />;
    }
  }      
    </code></pre>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
  class GreetingDetail extends React.Component {
    render() {
      return (
        &lt;input name="name" . . . />
        &lt;input name="greeting" . . . />
        &lt;button onClick={() => this.props.onSave({
          name: this.state.name,
          greeting: this.state.greeting
          })
          }>Add&lt;/button>
      )
    }
  }            
                  </code></pre>
      </section>



      <section>
        <h3>Komponenten in Hierarchien</h3>
        <p>Beispiel: Unsere Anwendung (Zusammenfassung)</p>
        <img src="ai/greeting-hierarchy.png" style="height:550px" />
      </section>

      <section>
        <h3>Smart und Dumb Components</h3>
        <p style="font-size: smaller;margin-bottom:0">(Alternativ: Container und Presentation Components)</p>
        <!--<img src="smart-dumb.jpg">-->
        <!--<img src="smart-dumb.png">-->
        <img style="margin-top:0;max-height:600px" src="images/component-communication.png">
      </section>

      <section>
        <h2>Übung 2: Eine komplette Anwendung zusammen setzen</h2>
        <h3>Füge deinen bestehenden Detail-View (
          <code>GreetingDetail</code>) und einen Master-View über eine Controller-Komponente zusammen</h3>
      </section>
      <section>
        <h3>Schritte</h3>
        <ol>
          <li>kopiere das Material aus
            <code>code/material/2-hierarchy</code> in deinen src-Ordner
          <li>erweitere im
            <code>GreetingController</code> die render-Methode, so dass dein
            <code>GreetingDetail</code> angezeigt wird, wenn der Benutzer den Add-Button klickt:
            <ul>
              <li>dort gibt es bereits einen Kommentar, der dir die richtige Stelle anzeigt und weitere Details enthält
              <li>übergib einen Callback der
                <code>addGreeting</code> nutzt
            </ul>
          <li>im deinem
            <code>GreetingDetail</code> brauchst du einen neuen Knopf, der mit dem neuen Gruß den Callback aufruft
            <br>
            <span style="font-size:85%">(Du kannst dein
              <code>GreetingDetail</code> verwenden, oder die Vorlage code/material/2-hierarchy/src/_GreetingDetail.js
              verwenden)</span>

        </ol>
      </section>
      <section>
        <h3>GreetingMaster</h3>
        <img src="images/greeting-master.png" style="border:0;box-shadow:0 0 0 0" />
      </section>
      <section>
        <h3>GreetingDetail</h3>
        <img src="images/greeting-detail.png" style="border:0;box-shadow:0 0 0 0" />
      </section>

      <section>
        <h3>Portals</h3>
        <p>Erlauben, außerhalb des "Root-React-Elements" zu rendern (zB für modale Dialoge)</p>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {
  render() {
    return
      React.createPortal(
        &lt;ModalDialog title="...">...&lt/ModalDialog>, 
        document.getElementById("portalRoot")
      );
  }
}
                      </code></pre>
        <pre class="fragment"><code data-trim contenteditable>
    // index.html
    &lt;html>
      &lt;body>
        &lt;div id="portalRoot"&lt;/div>
        &lt;div id="mount">&lt;/div>
      &lt;/body>
      &lt;script src="dist/main.js">&lt;/script>
    &lt;/html>
    </code></pre>
      </section>
      <section>
        <h3>Error Boundaries</h3>
        <p>Fehler während des Renders abfangen (statt try/catch)</p>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
  class GreetingController extends React.Component {
    componentDidCatch(error, info) {
      this.setState({hasError: true});
    }

    render() {
      if (this.state.hasError) {
        return &lt;ErrorDialog 
          onClick={() =&gt; this.setState({hasError: false})}>Fehler!/&lt;ErrorDialog>
      }

      return &lt;GreetingMaster />
    }
  }
                        </code></pre>
        <p class="fragment">Fängt nur Fehler der Unterkomponenten, nicht Fehler der eigenen render-Methode!</p>
      </section>
      <section id="t3">
        <h1>Teil III</h1>
        <h2>Daten lesen und schreiben vom Server</h2>
        <a href="code/schritte/3-remote/public/index.html" target="_blank">Ziel-Anwendung</a>
      </section>

      <section>
        <h3>Herausforderungen</h3>
        <ol>
          <li>Wie machen wir das Laden und Speichern technisch?
          <li>Wo steht der Code zum initialen Laden der Grüße? (beim Start der Anwendung)
          <li>Wo speichern wir?
          <li>Wie funktioniert asynchrone Verarbeitung in React?
        </ol>
      </section>

      <section>
        <h3>Server-Calls</h3>
        <ul>
          <li>React macht keine Angabe, wie Server-Calls (technisch) gemacht werden</li>
          <li>Häufig in React verwendet:
            <b>fetch</b> API
            <ul>
              <li>Browser-API zum Ausführen von HTTP Requests</li>
              <li>
                <a href="http://caniuse.com/#search=fetch" target="_blank">hohe Verbreitung</a>
              </li>
              <li>Spezifikation:
                <a href="https://fetch.spec.whatwg.org/" target="_blank">https://fetch.spec.whatwg.org/</a>
              </li>
              <li>Polyfill:
                <a href="https://github.com/github/fetch" target="_blank">https://github.com/github/fetch</a>
              </li>
            </ul>
        </ul>
      </section>
      <section>
        <h3>Beispiel: fetch</h3>
        <p> Daten lesen per GET</p>
        <pre><code class="javascript" contenteditable data-trim>
// Für GET Zugriff reicht es, die URL anzugeben:

fetch('http://localhost:7000/api/greetings')
  .then(response => response.json())
  .then(json => /* ... */)
  .catch(ex => console.error('request failed', ex));
</code></pre>
      </section>
      <section>
        <h3>Beispiel #2: fetch</h3>
        <p>Daten lesen per POST</p>
        <div class="fragment">
          <p>
            <code>fetch</code> erwartet als zweiten Parameter ein Objekt mit Konfigurationsparametern, u.a:
            <ul>
              <li>
                <code>method</code>: gibt die HTTP Methode an (
                <code>PUT</code>,
                <code>POST</code>,
                <code>DELETE</code>, ...)</li>
              <li>
                <code>headers</code>: Objekt mit HTTP Headern für den Request</li>
              <li>
                <code>body</code>: Der Request-Payload (als String)</li>
            </ul>
        </div>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
fetch(url, {
  method: 'POST',
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(payload)
})
  .then(...)
    </code></pre>
      </section>


      <section data-state="exkurs">
        <h2>ES6: Promises</h2>
      </section>
      <section data-state="exkurs">
        <h3>Ein Promise ist ein Versprechen auf einen Wert</h3>
        <h4 class="fragment">Wird evtl. erst in der Zukunft eingelöst</h4>
      </section>

      <section data-state="exkurs">
        <h3>Verkettete Ausführung</h3>
        <pre><code class="javascript" contenteditable>const promise = . . .;
</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>// then returns a new promise
const promise2 = promise.then(value => `${value} plus stuff`);</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>promise2.then(value => console.log(value));
// Output after 1 second: Result from promise plus stuff
</code></pre>
      </section>
      <section data-state="exkurs">
        <h3>Fehler führen zum Abbruch der Chain</h3>
        <h4>Allerdings
          <b>muss</b> man etwas tun, um das mitzubekommen: catch()</h4>
      </section>

      <section data-state="exkurs">
        <h3>Catch-Klausel im Erfolgsfall</h3>
        <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
    })
    .then(() => {
        console.log('This will be printed');
    })
    // this will NOT be printed as no error occured
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// This will be printed</code></pre>
      </section>
      <section data-state="exkurs">
        <h3>Catch-Klausel im Fehlerfall</h3>
        <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
        throw new Error('Something went wrong');
    })
    .then(() => {
        console.log('This will NOT be printed');
    })
    // this will be printed
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// error:  [Error: Something went wrong]</code></pre>
      </section>

      <section>
        <h3>fetch im Detail</h3>

        <pre><code class="javascript" contenteditable data-trim>
// 1. fetch returns a promise, that will be resolved
// with a Response object when response is received
// from server
fetch('http://localhost:7000/api/greetings')

// 2. the Response object contains a json() function,
// that returns the parsed JSON from the Response body
  .then(response => response.json())

// 3. with the resolved JSON object we set the
// component state (=&gt; leads to re-rendering)
  .then(json => this.setState({greetings: json})

// 4. in case something goes wrong (during request,
// request processing or rendering)
  .catch(ex => console.error('request failed', ex));
// as an alternative we could set and render an error msg:
//  .catch(ex => this.setState({error: ex})
</code></pre>
        <p>
          <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API Doku</a>
        </p>
      </section>
      <section>
        <h3>fetch mit async/await</h3>

        <pre class="fragment"><code class="javascript" contenteditable data-trim>
async function loadGreetings() {          
  try {
    const response = await fetch('http://localhost:7000/api/greetings');
    const json = await response.json();
    this.setState({greetings: json});
  } catch (err) {
    console.error("Loading failed: ", ex);
    // Alternative (set error message as state):
    // this.setState({error: err})
  }
}
  </code></pre>
        <span class="fragment">
          <ul>
            <li>Empfehlung: async/await statt Promise-Ansatz verwenden</li>
            <li>Insbesondere bei komplexen Abläufen oder mehreren fetch-Aufrufen viel einfacher</li>
          </ul>
        </span>

      </section>

      <section data-state="exkurs">
        <h3>Alternative zu Promises</h3>
        <h2>async / await</h2>
        <p>Erlauben es, asynchronen Code "linear" hinzuschreiben</p>
        <ul class="fragment">
          <li>Seit ECMASCript 2017 Standard</li>
          <li>Babel und TypeScript können nach ES5 compilieren</li>
          <li>Promise Polyfill für ältere Browser verwenden</li>
        </ul>
      </section>

      <section data-state="exkurs">
        <h3>async / await</h3>
        <ul>
          <li class="fragment">
            <code>aync</code> definiert "async functions"</li>
          <li class="fragment">
            <code>aync</code> functions liefern&nbsp;
            <b>immer</b> ein Promise zurück:
            <pre><code class="javascript" contenteditable data-trim>
async function greet(name) {
  return `Hello, ${name}`;
}

const greeting = greet('Klaus');

// greeting ist ein Promise!
console.log(greeting instanceof Promise); // => true
console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                </code></pre>
          </li>
          <li class="fragment">
            <code>aync</code> function als Fat Arrow function:
            <pre><code class="javascript" contenteditable data-trim>
const greet = async (name) => `Hello, ${name}`;                
  
const greeting = greet('Klaus');
  
// greeting ist ein Promise!
console.log(greeting instanceof Promise); // => true
console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                  </code></pre>
          </li>
          <li class="fragment">
            Nur in
            <b>async functions</b> kann
            <code>await</code> verwendet werden!</li>
        </ul>
      </section>

      <section data-state="exkurs">
        <h3>async / await</h3>
        <p>
          <code>await</code> wartet auf erfüllte Promises</p>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
async function greet(name) {
  return `Hello, ${name}`;
}

// oder:
function greet(name) { return new Promise(...); }

async function sayWhat(name) {
  const greeting = await greet(name);

  // ...Achtung! Hier zwischen kann Zeit vergehen...

  // greeting ist ein String!
  console.log(greeting); // => Hello, ...
}
                  </code></pre>
      </section>
      <section data-state="exkurs">
        <h3>async / await</h3>
        <p>Statt
          <code>then</code> bzw
          <code>catch</code> werden mehrere
          <code>await</code> Statements bzw Exception Handling verwendet:</p>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Liefert ein Promise zurück
async function loadUser(username) { . . . };
async function loadProfileDate(userId) { . . .};

async function loadData() {
  try {
    const user = loadUser('klaus');
    const profile = loadProfileData(user.userId);
  } catch (e) {
    console.error("Something failed")
  }
}
                    </code></pre>
      </section>
    
      <section data-state="exkurs">
        <h3>async / await</h3>
        <p>Auf mehrere Promises parallel warten #2</p>
        <p>Mit
          <em>Array Destructuring</em>
        </p>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
  // Liefert ein Promise zurück
  async function loadUser(userId) { . . . };
  async function loadProfileDate(userId) { . . .};
    
  async function loadData(userId) {
    try {
      const [user, profileData] = await Promise.all([
        loadUser(userId),
        loadProfileData(userId)
      ]);

      . . .
    } catch (e) {
  
      // wenn mind einer Aufrufe schief geht
      console.error("Something failed")
    }
  }
                        </code></pre>
      </section>
      <section>
        <h3>Wann werden Daten gelesen und geschrieben?</h3>
      </section>
      <section>
        <h3>Initiales Laden von Daten</h3>
        <p style="font-size:80%">Komponenten können optionale
          <a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle" target="_blank">Lifecycle-Methoden</a>
          haben</p>
        <img style="max-height: 500px;margin:0" src="images/react-lifecycle-1.png" />
        <p style="font-size:40%">(c) "React: Die praktische Einführung in React, React Router und Redux", dpunkt 2016</p>
      </section>
      <section>
        <h3>Initiales Laden von Daten</h3>
        <div class="fragment">
          <p>
            <code>componentDidMount</code> wird aufgerufen, wenn Komponente ins DOM gerendert wurde</p>
          <p>Hier werden Daten üblicherweise initial geladen:</p>
          <pre><code class="javascript" contenteditable data-trim>class GreetingController extends React.Component {
  constructor(props) {
    // intial state (empty now)
    this.state = { greetings: [] };
  }

  // 'async' wegen 'await' notwendig (sonst ohne 'async' hinschreiben)
  async componentDidMount() {
    try {
      const response = await fetch('/api/greetings');
      const json = await response.json();
      this.setState({ greetings: json});
    } catch (error) { . . .}
  }
}
                </code></pre>
          <p class="fragment">
            <em>Empfehlung:</em> Zugriffe auf Server in externes Modul auslagern (besser test- bzw mockbar)</p>
        </div>
      </section>
      <section>
        <h3>Speichern von Daten</h3>
        <p>Zum Beispiel als Folge einer Benutzerinteraktion:</p>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>class GreetingController extends React.Component {
  render() {
    ...
      &lt;GreetingDetail onSave={greeting => this.saveGreeting(greeting)} />
    ...
  }
  async saveGreeting(greetingToBeSaved) {
    try {
      const response = await fetch('/api/greetings', {
        method: 'POST',
        headers: ...,
        body: JSON.stringify(greetingToBeSaved)
      });
      const newGreeting = response.json();

      // Neuen Gruss an bestehende Liste anfuegen und State neu setzen
      const newGreetings = [ ...this.state.greetings, newGreeting ];
      this.setState({greetings: newGreetings});
    } catch (err) { . . . }
  }
}
                </code></pre>
      </section>

      <section>
        <h2>Übung: Laden und Speichern der Daten von/auf einem Server</h2>
        <p>
          <em>Entwickle auf Basis von fetch eine Version des GreetingControllers, der die Daten auf dem Server laden
            und dort
            wieder speichern kann</em>
        </p>
        <p>Der Server ist bereits vorgegeben und kann mit
          <code>npm run start-backend</code> im Root-Verzeichnis gestartet werden. Er ist dann unter Port 7000
          erreichbar</p>
      </section>
      <section>
        <h3>Schritte</h3>
        <ol>
          <li>Kopiere
            <code>code/material/3-remote/GreetingController.js</code> in deinen Arbeitsbereich
          <li>Die Serverzugriffe sollen in
            <code>loadGreetings</code> und
            <code>saveGreeting</code> erfolgen</li>
          <li>Dort sind bereits entsprechende TODOs für dich eingetragen</li>
        </ol>
      </section>


      <section id="t4">
        <h1>Teil IV</h1>
        <h2>React mit TypeScript entwickeln</h2>
        <p>
          <a href="code/schritte/5-typescript/public/index.html" target="_blank">Ziel-Anwendung</a>
        </p>
        <h3>Themen</h3>
        <ul>
          <li>
            <a href="#/t4a">TypeScript Grundlagen</a>
          </li>
          <li>
            <a href="#/t4b">React-Anwendungen mit TypeScript entwickeln</a>
          </li>
        </ul>
      </section>

      <section id="t4a">
        <h2>Hintergrund: TypeScript</h2>
        <p>
          <em>TypeScript is a superset of JavaScript that compiles to plain JavaScript </em>(
          <a href="http://www.typescriptlang.org/" target="_blank">http://www.typescriptlang.org/</a>)</p>
        <ul>
          <li>Erweitert JavaScript um ein Typen System</li>
          <li>Jeder gültige JavaScript Code ist auch gültiger TypeScript Code</li>
          <li>Mittels des TypeScript Compilers wird aus TS Code JavaScript Code</li>
          <li>Entwickelt von Microsoft</li>
          <li>Unterstützung in vielen IDEs (z.B. Anzeige von Fehlern, Refactoring, ...) </li>
        </ul>
      </section>

      <section>
        <h3>Wichtige Unterschiede zu Java/C#</h3>
        <ul>
          <li>Typ-Informationen sind nach dem compilieren weg (keine Reflection API etc)
            <ul>
              <li>Das gilt auch für Sichtbarkeiten und readonly Felder</li>
            </ul>
          </li>
          <li>Es wird auch JavaScript-Code erzeugt, selbst wenn es einen Compile-Fehler gibt</li>
          <li>Im Gegensatz zu Java/C# sind bei TypeScript zwei Typen kompatibel, sofern sie
            <b>dieselbe Struktur</b> haben
          </li>
        </ul>
      </section>

      <section>
        <h3>TypeScript Grundlagen</h3>
        <p>Typ-Angaben werden hinter einen Bezeichner geschrieben</p>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Variablen können Typ-Informationen bekommen
let foo: string;
foo = 'yo';
// Error: number: This type is incompatible with string
foo = 10;
               </code></pre>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Funktionen
function sayIt(what: string): string {
  return `Saying: ${what}`;
}

sayIt('Klaus'); // ok
sayIt(10); // error
</code></pre>


        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Arrow Funktionen
const sayIt = (what: string): string => `Saying: ${what}`;

sayIt('Moin');
sayIt(123); // Error: Argument of type '123' is not assignable
            // to parameter of type 'string'.
</code></pre>
      </section>

      <section>
        <h2>Eingebaute Typen</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// string
let city: string = 'Hamburg';

// boolean
let isDone: boolean = false;

// number
let theAnswer: number = 42;

// array (note the [])
let cities: string[] = ['Hamburg', 'Barcelona'];
// alternative:
let languages: Array&lt;string> = ['JavaScript', 'TypeScript'];

// any
let theUnknown: any = 'Who cares';
theUnknown = 666; // ok
theUnknown = true; // ok
let a: number = theUnknown; // ok

// void
function log(s: string): void { /* ... */ }
            </code></pre>

      </section>
      <section>
        <h2>Typen können abgeleitet (inferred) werden</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let city = 'Hamburg'; // city ist ein String

city = 42;
// Fehler: [ts] Type '42' is not assignable to type 'string'.
</code></pre>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Explizite Angabe eines Types (parameter)
// und abgeleiteter Typ (Return Type der Funktion)

function sayIt(what: string) {
  return `Saying: ${what}`;
}

const said: string = sayIt('Hello TypeScript'); // ok
const saidItWrong: number = sayIt('Hello TypeScript'); // error!


</code></pre>
      </section>
      <section>
        <h2>Strict Mode</h2>
        <ul>
          <li>
            <b>strict</b>: seit TypeScript 2.3</li>
          <li>Shortcut u.a. für:
            <ul>
              <li>
                <b>noImplicitAny</b>:
                <code>any</code> muss explizit hingeschrieben werden</li>
              <li>
                <b>strictNullChecks</b>: Null muss explizit erlaubt werden (z.B. bei Rückgabewerten)</li>
            </ul>
          </li>
          <li>Empfehlung: für neue Projekte einschalten, sonst Schrittweise</li>
        </ul>
        <p>
          <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank">https://www.typescriptlang.org/docs/handbook/compiler-options.html</a>
        </p>
      </section>
      <section>
        <h2>Type Check ausschalten</h2>
        <p>Mit
          <code>@ts-ignore</code> (als Kommentar) kann wird die Überprüfung der nächsten Zeile ausgeschaltet:</p>
        <pre><code class="typescript line-numbers" contenteditable data-trim>
let city:string = "Hamburg";

city = 20259; // error: [ts] Type '20259' is not assignable to type 'string'.

// @ts-ignore
city = 20259; // ok                
</code></pre>
        <p class="fragment">Nützlich in corner cases, die nur schwer mit TypeScript abbildbar sind oder bei Migration</p>
      </section>
      <section>
        <h2>null und undefined</h2>
        <div class="fragment">
          <p>
            <code>null</code> muss explizit zugelassen werden
            <em>(strictNullChecks</em>):</p>
          <pre><code class="typescript line-numbers" contenteditable data-trim>
let city:string = null; //Type 'null' is not assignable to type 'string'.

let optionalCity:string|null = null; // OK
            </code></pre>
        </div>
        <div class="fragment">
          <p>Optionale Parameter können mit ? gekennzeichnet werden (erlauben dann auch
            <code>undefined</code>)</p>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function greet(name: string, greeting?: string) {
  console.log(`${greeting || 'Hello'}, {name}`);
}

greet('Susi', 'Moin')// Moin, Susi

// 2. Parameter ist optional:
greet('Klaus'); // Hello, Klaus

greet('Peter', null); // Argument of type 'null' is not assignable
                      // to parameter of type 'string | undefined'.
            </code></pre>
        </div>
      </section>


      <section>
        <h2>Klassen</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
  what: string; // Typ-Angabe für Felder ist erforderlich

  constructor(what: string) { // Typ-Angabe für Parameter ist erforderlich
    this.what = what;
  }

  // Angabe des Return-Types optional
  sayIt(): string {
    return `Saying: ${this.what}`;
  }
}

</code></pre>
      </section>

      <section>
        <h2>Klassen (Sichtbarkeiten)</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
  // Erlaubte Sichtbarkeiten: private | protected | public
  private what: string; 

  constructor(what: string) { 
    this.what = what;
  }

  sayIt(): string {
    return `Saying: ${this.what}`;
  }
}

const sayer = new Sayer("Susi");
sayer.what = ""; // ERROR: Property 'greeting' is private

</code></pre>
      </section>
      <section>
        <h2>Klassen (Parameter Properties)</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
  // identisch zu vorherigem Beispiel
  constructor(private what: string) {
  }

  sayIt(): string {
    return `Saying: ${this.what}`;
  }
}
</code></pre>
      </section>
      <section>
        <h2>Klassen (readonly Felder)</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {

  readonly what: string; 

  // Alternativ:
  constructor(readonly public what: string) {
  }

  setWhat(newWhat: string) {
    this.what = newWhat; // ERR Cannot assign to 'what' 
                         // because it is a read-only property.
  }
}
</code></pre>
      </section>
      <section>
        <h2>Eigene Typen</h2>
        <p>Mit
          <code>interface</code> können eigene Typen defniert werden:</p>

        <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// Komplexer Typ
interface Person {
	name: string; // Pflicht
	livesIn?: string; // Optional
}

const susi: Person = { // OK
	name: 'Klaus',
	livesIn: 'Hamburg'
};
const klaus: Person = { // OK (livesIn ist optional)
	name: 'Klaus'
}

const helmut: Person = {} // Error: Property 'name' is missing

const lukas: Person = {
	name: 'Lukas',
	profession: 'Lokführer'
} // Error: 'profession' does not exist in type 'Person'.
               </code></pre>

      </section>

      <section>
        <h2>Typ Kompatibilität</h2>
        <em>Im Gegensatz zu Java/C# ("nominal typing") sind bei TypeScript zwei Typen kompatibel, sofern sie
          <b>dieselbe Struktur</b> haben ("structural typing")</em>
        <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Book {
	title: string
}

interface Movie {
	title: string
}

const book:Book = { title: "Das Kapital" };
const movie:Movie = book; // OK, obwohl Book !== Movie
               </code></pre>
      </section>
      <section>
        <h2>Generics</h2>
        <p>Generische Typen verwenden</p>
        <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Person { name: string };
interface Movie { title: string };

let persons:Array&lt;Person&gt; = [];
let movies:Array&lt;Movie&gt; = [];

persons.push({name: 'Klaus'});
movies.push({title: 'Batman'});

persons.push({title: 'Casablanca'}) // error ('title' not in Person)

persons = movies; // error

      </code></pre>
      </section>
      <section>
        <h2>Arbeiten mit externen Bibliotheken</h2>
        <p>Typings installieren und verwenden</p>
        <ul>
          <li>Typings sind optional, können aber über zusätzliches Deklarations-File hinzugefügt werden
            <li>Typings für Kern-Bibliotheken kommen mit TypeScript Compiler
              <li>Manche Bibliotheken werden bereits mit TypeScript Deklarations-Files ausgeliefert (z.B. Redux)
                <li>Typen können über
                  <a href="https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/" target="_blank">npm</a> installiert werden und sind dann ohne weiter Schritte nutzbar (z.B.
                  <em>npm install @types/react --save</em>)
        </ul>
      </section>

      <section>
        <h2>Arbeiten mit externen Bibliotheken</h2>
        <p>Typings selber beschreiben</p>
        <ul>
          <li>Workaround, wenn keine Typings vorhanden sind

            <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
declare module 'jquery';

declare module 'module-with-default-export' {
  let str: string;
  export default str;
}
                          </code></pre>
          </li>
        </ul>
      </section>

      <section id="t4b">
        <h2>React Anwendungen mit TypeScript</h2>
        <em>State und Properties von Komponenten werden mit Typen beschrieben</em>
      </section>
      <section>
        <h2>Voraussetzungen</h2>
        <ul>
          <li class="fragment">React Type Deklarationen installieren:
            <pre><code data-trim contenteditable class="line-numbers bash" data-leftpad>
npm install --save @types/react @types/react-dom
        </code></pre>
          </li>
          <li class="fragment">(Externe) Module, die kein Default-Export haben, müssen mit
            <code>import *</code> importiert werden:
            <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// JavaScript/Babel:
import React from 'react';

// TypeScript
import * as React from 'react';
        </code></pre>
          </li>
          <li class="fragment">Dateien, die JSX-Code enthalten, müssen mit
            <code>.tsx</code> enden</li>
          <li class="fragment">Compiliert wird mit TypeScript (statt Babel). Integration in Webpack mit
            <a href="https://github.com/s-panferov/awesome-typescript-loader" target="_blank">
              <code>awesome-typescript-loader</code>
            </a>
          </li>
        </ul>
      </section>
      <section>
        <h2>Getypte React Komponenten</h2>
        <p>
          <code>React.Component</code> ist eine generische Klasse, die einen Typ für Properties und State erwartet</p>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Greeting = {name: string; greeting: string};

interface GreetingDetailProps {
    greeting?: Greeting;
    onSave: (newGreeting: NewGreeting) => void;
}

interface GreetingDetailState {
    name: string;
    greeting: string;
}
            </code></pre>

        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>

class GreetingDetail
  extends React.Component&lt;GreetingDetailProps, GreetingDetailState> {
  // ...
}
            </code></pre>
      </section>
      <section>
        <h3>Typsicherheit in React Komponenten</h3>
        <p>Properties und State sind typsicher</p>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
constructor(props: Props) {
    super(props);

    this.state = { name: '', greeting: ''} // OK

    // ERROR: Object literal may only specify known properties,
    // and 'aha' does not exist in type 'Readonly&lt;State>'
    this.state = {name: '', greeting: '', aha: 10};

    // ERROR: Cannot assign to 'greeting' because
    // it is a constant or a read-only property.
    this.state.greeting = 'no way';
}

render() {
  // ERROR: Property 'nothere' does not exist on type...
  return &lt;div>{this.props.nothere}&lt;/iv>;
}
               </code></pre>
      </section>
      <section>
        <h2>React Events in TypeScript</h2>
        <span class="fragment">
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
class GreetingDetail extends React.Component&lt;Props, State> {
  // . . .
  updateModel(event: React.SyntheticEvent&lt;HTMLInputElement>) {
    // 'currentTarget' anstatt 'target' verwenden:
    const { name, value } = event.currentTarget;
    // . . .

    // Compile error! 
    this.setState({[name]}: value);

    // @ts-ignore 
    this.setState({[name]}: value);
  }
}

        </code></pre>
          <p>
            <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682" target="_blank">
              <code>target</code> vs
              <code>currentTarget</code>
            </a>
          </p>
        </span>

      </section>
      <section>
        <h2>Functional Components</h2>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type GreetingMasterProps = {
    greetings: Greeting[]
    onAdd: () => void
};
        </code></pre>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
const GreetingMaster = (props: GreetingMasterProps) => {
    const {greetings, onAdd} = props;
    // . . .
}

        </code></pre>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// or
const GreetingMaster = ({greetings, onAdd}: GreetingMasterProps) => {
    // . . .
}

        </code></pre>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// or
const GreetingMaster: React.FunctionComponent&lt;GreetingMasterProps> = props => {
    const {greetings, onAdd} = props;
    // . . .
}
        </code></pre>
      </section>
      <section>
        <h2>Übung: Eine Komponente auf TypeScript umstellen</h2>
        <h3>
          <em>Stelle die GreetingDetail Komponente auf TypeScript um</em>
        </h3>
        <div style="font-size: 80%">
          <p>
            <b>Hinweis: </b> Bitte arbeite dazu in dem neuen Workspace
            <code>code/workspace-typescript</code>:</p>
          <ul>
            <li>Dieses Verzeichnis enthält die Anwendung aus unserem letzten Schritt, aber in TypeScript implementiert</li>
            <li>Lediglich das
              <code>GreetingDetail</code> ist noch in JavaScript implementiert</li>
            <li>Du kannst den Webpack Server in diesem Verzeichnis ebenfalls mit
              <code>npm start</code> starten</li>
            <li>Denk dran, deinen laufenden Webpack Server vorher zu beenden</li>
          </ul>
        </div>
      </section>
      <section>
        <h2>Schritte</h2>
        <ol style="font-size:80%">
          <li>Definiere einen Typen für die Properties und den State und passe die
            <code>GreetingDetail</code>-Klasse an</li>
          <li>Füge der Komponente das
            <code>input</code>-Property hinzu (Type:
            <code>HTMLInputElement</code>)</li>
          <li>Experimentiere (optional):
            <ul>
              <li>Was passiert, wenn Du im
                <code>GreetingDetail</code> auf ein nicht bekanntes Property zugreifst?</li>
              <li>Was passiert, wenn Du im
                <code>GreetingDetail</code> den State mit
                <code>this.state = { . . .}</code> neu setzt?
              </li>
              <li>Was passiert, wenn Du beim Aufrufen des
                <code>GreetingDetail</code> (
                <code>GreetingController</code>) ein zusätzliches Property übergibst?</li>
            </ul>
          </li>
        </ol>
      </section>
      <section id="t5">
          <h1>Teil V</h1>
          <h2>Testen von React Anwendungen</h2>
          <ul style="font-size:85%">
            <li>
              <a href="code/schritte/4-test/public/index.html" target="_blank">Ziel-Anwendung</a>
            </li>
            <li>
              <a href="code/schritte/4-test/test-report.html" target="_blank">Test Report</a>
            <li>
              <a href="code/schritte/4-test/coverage/lcov-report/index.html" target="_blank">Coverage Report</a>
            </li>
          </ul>
        </section>
  
        <section data-transition="slide none">
          <h2>Was testen wir überhaupt?</h2>
          <ul>
            <li class="fragment">
              <b>UI-unabhängige Logik</b> (z.B. Services, Backend-Calls)</li>
            <li class="fragment">
              <b>Rendern</b> (wird meine Greeting-Liste für ein Satz von Greetings korrekt dargestellt)</li>
            <li class="fragment">
              <b>Interaktionen</b> (funktionieren meine Event-Listener korrekt)</li>
            <li class="fragment">
              <b>Verhalten im Browser</b> (z.B. korrekte Darstellung, Browser-spezifisches JavaScript, Arbeiten mit
              history, Titelzeile,
              Scrollbars etc)</li>
          </ul>
        </section>
  
        <section data-transition="slide none">
          <h2>Was testen wir überhaupt?</h2>
          <ul>
            <li style="color: lightgrey">
              <b>UI-unabhängige Logik</b>
            </li>
            <li>
              <b>Rendern</b> (wird meine Greeting-Liste für ein Satz von Greetings korrekt dargestellt)
            </li>
            <li>
              <b>Interaktionen</b> (funktionieren meine Event-Listener korrekt)
            </li>
            <li style="color: lightgrey">
              <b>Verhalten im Browser</b> (z.B. korrekte Darstellung, Browser-spezifisches JavaScript, Arbeiten mit
              history, Titelzeile,
              Scrollbars etc)</li>
          </ul>
        </section>
  
        <section>
          <h2>Anforderungen</h2>
          <ul>
            <li class="fragment">Komponenten müssen im Test gerendert werden können</li>
            <li class="fragment">Gerenderte Komponenten/HTML-Elemente müssen gefunden und validiert werden</li>
            <li class="fragment">Zustand und Properties der Komponenten müssen veränderbar sein</li>
            <li class="fragment">Events müssen getriggert oder simuliert werden können</li>
            <li class="fragment">Interaktion mit DOM muss evtl möglich sein</li>
          </ul>
        </section>
  
        <section>
          <h1>Jest</h1>
          <p>
            <em>"Painless JavaScript Testing" (
              <a href="http://facebook.github.io/jest/" target="_blank">http://facebook.github.io/jest/</a>)</em>
          </p>
          <p class="fragment">Vollständige Test-Lösung, wird von Facebook für Testen von React verwendet:</p>
          <ul>
            <li class="fragment">Test Runner</li>
            <li class="fragment">Specs, Assertions, Mocks</li>
            <li class="fragment">Code Coverage</li>
            <li class="fragment">Snapshot testing</li>
          </ul>
        </section>
        <section>
          <h3>Beispiel: Ein einfacher Test</h3>
          <pre><code class="javascript" contenteditable data-trim>// sum.js
  export const sum = (a,b) => a+b;
  </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>// sum.test.js
  import {sum} from '../sum.js';
  
  test('sum of 2 and 2 is 4', () => {
    expect(sum(2, 2)).toBe(4);
  });
  
  test('sum of 2 and 2 is not 3', () => {
    expect(sum(2, 2)).not.toBe(3);
  });
          </code></pre>
        </section>
        <section>
          <h2>Testcases</h2>
          <p>
            <code>test</code> oder
            <code>it</code>
          </p>
          <pre><code data-trim contenteditable>test('it should work', () => {
    expect(...).toBe(...);
  });</code></pre>
          <pre><code data-trim contenteditable>it('it should also work', () => {
    expect(...).toBe(...);
  });</code></pre>
        </section>
        <section>
          <h2>Testsuites</h2>
          <ul>
            <li>Testsuites (optional, müssen nicht verwendet werden)
              <pre><code data-trim contenteditable>describe('some feature', () => {
    test(() => {...});
    test(() => {...});
    test(() => {...});
  });</code></pre>
            </li>
            <li class="fragment">Überspringen (
              <code>skip</code>) / Auswählen (
              <code>only</code>) einzelner Tests:
              <pre><code data-trim contenteditable>describe.only('some feature', () => { } );
  describe.skip('another feature', () => { });
  
  test.only('should work', () => { });
  test.skip('does not work, skip for now', () => { });
  
  </code></pre>
  
            </li>
          </ul>
        </section>
        <section>
          <h2>Expectations und Matcher</h2>
          <div class="fragment">
            <p>
              <code>expect()</code> liefert eine Expectation zurück, auf der Matcher definiert sind:</p>
            <pre><code data-trim contenteditable>expect(actual).toXyz(expected);
  // for example:
  expect("Hello Jest").toBe("Hello Jest"); // => ok
  </code></pre>
          </div>
          <div class="fragment">
            <p>Einige Matcher</p>
  
            <pre><code data-trim contenteditable>// Vergleich auf Identität
  expect(actual).toBe(expected);
  // Inhaltsvergleich:
  expect(actual).toEqual(expected);
  // true / false / null:
  expect(actual).toBeTruthy();
  expect(actual).toBeFalsy();
  expect(actual).toBeNull();
  // Länge (Array oder String)
  expect(actual).toHaveLength(123);
  </code></pre>
          </div>
          <p class="fragment">
            <a href="https://facebook.github.io/jest/docs/expect.html#content">https://facebook.github.io/jest/docs/expect.html#content</a>
          </p>
  
        </section>
  
        <section>
            <h2>Mock Funktionen (in Jest)</h2>
            <ul>
                <li class="fragment"><code>jest.fn()</code> erzeugt eine Mock-Funktion
                    <pre><code data-trim contenteditable>// Liefert undefined zurück, wenn ausgeführt
const aMockFn = jest.fn();

aMockFn(); // => undefined
                    </code></pre>
                <li class="fragment">Implementierung der Mockfunktion kann als Parameter übergeben werden:
                    <pre><code data-trim contenteditable>
const aMockFn = jest.fn( param => `Hello, ${param}` );

console.log(aMockFn('World'));
// => Hello, World
                </code></pre>
                </li>
            </ul>
        </section>
        <section>
            <h2>Mock Funktionen</h2>
            <li class="fragment">Aufrufe sicherstellen
                <pre><code data-trim contenteditable>
const aMockFn = jest.fn( param => `Hello, ${param}` );
// use aMockFn somewhere in your code, then assert:

expect(aMockFn).toHaveBeenCalled();
expect(aMockFn).toHaveBeenCalledWith('World');
</code></pre>
            </li>
            <li class="fragment">Aufrufe: <code>fn.mock.calls</code>
                <pre><code data-trim contenteditable>
const mockFn = jest.fn();
mockFn('Hello', 'World');
expect(mockFn.mock.calls).toHaveLength(1);
expect(mockFn.mock.calls[0].toBe(['Hello', 'World']);
</code></pre>
            </li>
            <li class="fragment">Zurücksetzen: Reset
                <pre><code data-trim contenteditable>
const mockFn = jest.fn();
mockFn('Hello', 'World');
expect(mockFn.mock.calls).toHaveLength(1);
jest.restAllMocks(); // or: mockFn.mockReset();
expect(mockFn.mock.calls).toHaveLength(0);
            </code></pre>
            </li>
        </section>
        <section>
            <h2>Mock modules</h2>
            <li class="fragment">Ein Modul mocken:
                <pre><code data-trim contenteditable>
// external module:
jest.mock('react-dom');
// internal module:
jest.mock('../../app/myDataService');

// alle Funktionen sind jetzt gemockt,
// "leere" Implementierung, return undefined)
</code></pre>
            </li>
            <li class="fragment">Implementierung für Mockfunktion:
                <pre><code data-trim contenteditable>
jest.mock('../../app/myDataService', () => ({
  loadData: jest.fn( () => ({data: 'mock data'}) );
});

console.log(myDataService.loadData());
// => {data: 'mock data'}
</code></pre>
            </li>
        </section>
        <section>
            <h2>Mock modules</h2>
            <li class="fragment">Funktionen aus gemockten Modulen sind Jest Mock Funktionen
                <pre><code data-trim contenteditable>
import myDataService from '../../app/myDataService';
jest.mock('../../app/myDataService');

// do something in code, that uses my dataservice
expect(myDataService).toHaveBeenCalled();

</code></pre>
            </li>
        </section>

       
  
        <section>
          <h3>React Test Renderer</h3>
          <p>
            <a href="https://www.npmjs.com/package/react-test-renderer">https://www.npmjs.com/package/react-test-renderer</a>
          </p>
          <p>Rendert React Komponenten in JSON Objekte (ohne DOM):</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';
  
  const component = renderer.create(
    &lt;GreetingMaster greetings={someGreetings} />
  );
  
  console.log(component.toJSON());
          </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  { type: 'div',
    props: {},
    children:  [
      { type: 'table', props: {}, children: [Object] },
      { type: 'button', props: [Object], children: [Object] }
    ]
  }
          </code></pre>
        </section>
        <section>
          <h3>"Snapshot Testing" mit Jest</h3>
          <p>
            <code>expect(obj).toMatchSnapshot()</code> vergleicht ein JSON-Objekt mit einer gespeicherten Datei:</p>
          <ul>
            <li class="fragment">Bei
              <b>erster</b> Ausführung: legt Snapshot-File an (
              <a href="images/jest-snapshot-file.png" target="_blank">Beispiel</a>)
              <ul>
                <li class="fragment">Snapshotdateien werden in Git versioniert</li>
              </ul>
            </li>
            <li class="fragment">Bei
              <b>folgenden</b> Ausführungen: erzeugt neuen Snapshot und vergleicht mit gespeichtertem Snapshot
            </li>
            <li class="fragment">Wenn Snapshots unterschiedlich
              <ul>
                <li>Fehler samt Diff (
                  <a href="images/jest-snapshot-diff.png" target="_blank">Beispiel</a>)</li>
                <li>Im Watch Mode kann Snapshot aktualisiert werden
                  <img src="images/jest-snapshot-update.png">
                </li>
              </ul>
            </li>
  
          </ul>
        </section>
  
        <section>
          <h3>Snapshot Testing mit Jest und React</h3>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';
  
  test('it should render correctly', () => {
  
    const someGreetings = [ . . . ];
  
    const component = renderer.create(
      &lt;GreetingMaster greetings={someGreetings} />
    );
  
    expect(component.toJSON()).toMatchSnapshot();
  });
          </code></pre>
          <p class="fragment">
            <em>Snapshot sagt nicht, ob UI richtig oder falsch gerendert wird, sondern nur, ob sie verändert wurde!</em>
          </p>
        </section>
  
        <section>
          <h3>Enzyme</h3>
          <p>
            <em>JavaScript Testing utilities for React (
              <a href="http://airbnb.io/enzyme/" target="_blank">http://airbnb.io/enzyme/</a>)</em>
          </p>
          <p>Bibliothek mit Funktionen zum Testen von React Komponenten</p>
          <ul>
            <li class="fragment">Rendern von Komponenten:
              <ul>
                <li>
                  <b>shallow</b> zum "flachen" Rendern einer Komponente</li>
                <li>
                  <b>mount</b> zum Rendern einer Komponete in einen (headless) DOM, z.B. jsdom</li>
              </ul>
            </li>
            <li class="fragment">Navigieren durch den DOM und Suchen von Elementen und Komponenten</li>
            <li class="fragment">Modifizieren von Komponenten und Auslösen von Events</li>
          </ul>
        </section>
  
        <section>
          <h3>Testen einer Komponente mit Jest und Enzyme</h3>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>import {mount} from 'enzyme';
  import GreetingController from '...';
  import GreetingDetail from '...';
  
  test('it should open detail view on button click', () => {
    // mount the component into a real dom (implemented by JSDom)
    const component = mount(&lt;GreetingController  />);
  
    // on initial render the list with greetings (GreetingMaster)
    // is visible but no GreetingDetail
    expect(component.find(GreetingDetail)).toHaveLength(0);
  
    // find the "add" Button...
    const addButton = component.find('button');
  
    // click on the button
    addButton.simulate('click');
  
    // now the GreetingDetail should be visible
    expect(component.find(GreetingDetail)).toHaveLength(1);
  });
          </code></pre>
        </section>
  
        <section>
            <h3>Testen von asynchronem (React) Code</h3>
            <p><a href="https://github.com/nilshartmann/jest-playground" target="_blank">Beispiel mit mehreren möglichen Strategien</a></p>
          </section>

          <section>
            <h2>UI Tests im Browser</h2>
            <h3>Test Cafe</h3>
            <ul>
            <li>Open-Source-Lösung als Selenium-Ersatz</li>
            <li>Testfälle werden in JavaScript oder TypeScript geschrieben</li>
            <li>Support für <a href="https://devexpress.github.io/testcafe/documentation/using-testcafe/common-concepts/browsers/browser-support.html" target="_blank">diverse Browser</a></li>
            <li>Homepage: <a href="https://github.com/DevExpress/testcafe" target="_blank">https://github.com/DevExpress/testcafe</a></li>
            </ul>
          </section>
          <section>
            <h2>Test Cafe II</h2>
            <ul>
              <li>Browser kann im Fehlerfall in <a href="https://devexpress.github.io/testcafe/documentation/using-testcafe/command-line-interface.html#--debug-on-fail" target="_blank">Debug-Mode gesetzt</a> werden</li>
              <li>Im Fehlerfall können automatisch <a href="https://devexpress.github.io/testcafe/documentation/using-testcafe/command-line-interface.html#-s---screenshots-on-fails" target="_blank">Screenshots erzeugt werden</a>S</li>
              <li>Funktioniert auch headless und im CI-Build (z.B. Jenkins)</li>
              <li>Testen vom Edge Browser: <a href="https://www.browserstack.com/test-on-microsoft-edge-browser#live-cloud" target="_blank">z.B. mit BrowserStack</a></li>
              </ul>
          </section>
          <section>
            <h2>Test Cafe III</h2>
            <p>Beispiel Workspace mit fertigen Testcafe UI Tests:</p>
              <p> <a href="https://github.com/nilshartmann/e2e-testing-playground" target="_blank">https://github.com/nilshartmann/e2e-testing-playground</a></li></p>
          </section>

      <section id="t6">
          <h1>Teil VI</h1>
          <h2>Client-seitiges Routing (Überblick)</h2>
          <a href="code/schritte/router-v4-typescript/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>
        <section>
          <h2>Warum Routing?</h2>
          <span>
            <p>Mappen von URLs auf Komponenten
              <br>
              <span style="font-size: 80%">(Navigation findet ohne Server-Roundtrip statt)</span>
            </p>
          </span>
          <span>
            <p>Komponenten halten (Teil) des Zustandes der Anwendung
              <br>
              <span style="font-size: 80%">Welche Komponente ist sichtbar (Master oder Detail)?</span>
              <br>
              <span style="font-size: 80%">Welche Daten werden dafür geladen (z.B. Greeting Id)</span>
            </p>
          </span>
        </section>
  
        <section>
          <h2>Herausforderungen</h2>
          <p>Auf Änderungen der URL reagieren
            <br>
            <span style="font-size: 80%">Ableiten des Zustandes aus der URL
              <br>Wenn sich die URL ändert, kein Server roundtrip</span>
          </p>
          <p>Hierarchische Komponentenstrukturen</p>
          <p>Beim Klick auf Links etc aktualisieren der URL</p>
        </section>
  
        <section>
          <h2>React Router</h2>
          <ul>
            <li>Kein Bestandteil von React</li>
            <li>Sehr häufig verwendet (de-facto Standard)</li>
            <li>Aktuelle Version 4:
              <a href="https://reacttraining.com/react-router/" target="_blank">
                https://reacttraining.com/react-router/</a>
            </li>
          </ul>
        </section>
        <section>
          <h3>Das Router-Objekt</h3>
          <p class="fragment">Top-Level-Objekt, das einmalig (oben) in der Komponenten Hierarchie eingebunden werden muss</p>
          <p class="fragment">Mehrere Ausprägungen zum Arbeiten mit den URL und der Browser History:
            <ul>
              <li class="fragment">
                <b>HashRouter</b>: codiert Pfad in angehängten Hash (#/greetings)</li>
              <li class="fragment">
                <b>BrowserRouter</b>: codiert Pfad direkt in URL (/greetings)</li>
            </ul>
          </p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import {HashRouter as Router} from "react-router-dom";
  
  const app = &lt;Router>&lt;GreetingController/>&lt;/Router>;
  
  ReactDOM.render(app, document.getElementById(...));
          </code></pre>
        </section>
  
        <section>
          <h3>Welche Komponente soll für einen Pfad gerendert werden</h3>
          <p class="fragment">Das
            <code>Route</code>-Objekt mappt Pfade auf Komponenten</p>
          <ul>
            <li class="fragment">
              Wird verwendet, wo Pfad-abhängig Komponenten ausgewählt werden sollen
              <ul>
                <li>vergleichbar mit intelligentem
                  <code>if</code>/
                  <code>switch</code> statement</li>
                <li>Kann überall in der Anwendung</b> verwendet werden (auf allen Hierarchie-Ebenenen) </li>
              </ul>
            </li>
            <li class="fragment">Mit
              <code>path</code> wird der Pfad übergeben, für den die Route matchen soll</li>
            <li class="fragment">Mit
              <code>component</code> wird die Komponente übergeben</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import {HashRouter as Router, Route} from "react-router-dom";
  
  const app = &lt;Router>
    &lt;Route path="/greet/:greetingId" component={GreetingDisplayController}/>
    &lt;Route path="/" component={GreetingController}/>
  &lt;/Router>;
  
  ReactDOM.render(app, document.getElementById(...));
          </code></pre>
        </section>
        <section>
          <h3>Route #2: Das render-Property</h3>
          <ul>
            <li>Statt einer Komponente kann eine Funktion übergeben werden, die eine Komponente zurückliefert</li>
            <li>Ermöglicht es, zusätzliche Properties an die Komponente zu übergeben</li>
            <li>Kann unterschiedliche Komponenten zurückliefern (z.B. für Authorisierung) </li>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  &lt;Route path="/"
    render={() => {
      return loggedIn ? 
        &lt;GreetingMaster greetings={initialGreetings} />
      :
        &lt;LoginForm />
    }}
  />
          </code></pre>
          </ul>
        </section>
        <section>
          <h3>Hintergrund: Pfade</h3>
          <p>In Routen werden
            <b>Pfade</b> angegeben, die mit der aktuellen URL verglichen werden</b>
            <ul>
              <li>Pfade sind per Default gültig für Teilstrings</li>
              <li>Mit
                <code>exact</code> kann das Verhalten verändert werden
                <li>Eine Route ohne
                  <code>path</code> matcht immer</li>
            </ul>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  // trifft zu für / und /greeting
  &lt;Route path="/" component={GreetingController}/>
  
  // trifft nur zu für /
  &lt;Route path="/" exact component={GreetingController}/>
  
  // passt auf jede URL:
  &lt;Route component={GreetingController}/>
  
          </code></pre>
            <ul>
              <li class="fragment">Kann variable Segmente enthalten:
              </li>
            </ul>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  &lt;Route path="/greeting/:greetingId"
        component={&lt;GreetingDisplay />} />
  
  // in GreetingDisplay kann die greetingId über
  // this.props.match.params.greetingId abgefragt werden
          </code></pre>
  
  
        </section>
        <section>
          <h3>Switch</h3>
          <ul>
            <li class="fragment">Wenn mehrere path-Ausdrücke matchen, werden mehrere Komponenten gerendert (z.B. "/" und "/greetings")</li>
            <li class="fragment">
              <code>Switch</code> sorgt dafür, dass nur die erste Komponente im Block gerendert wird</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import {HashRouter as Router, Route, Switch} from "react-router-dom";
  
  const app = (
    &lt;Router>
      &lt;Switch>
        &lt;Route path="/greet/:greetingId" component={GreetingDisplayController}/>
        &lt;Route path="/" component={GreetingController}/>
  
        // "No match": ohne Pfad
        &lt;Route component={NotFoundPage}/>
  
      &lt;/Switch>
    &lt;/Router>
  );
  
  ReactDOM.render(app, document.getElementById(...));
          </code></pre>
        </section>
  
        <section>
          <h3>Router Properties für Komponente</h3>
          <p>Der Router übergibt automatisch drei Properties an die gerenderte Komponente:</p>
          <ul>
            <li class="fragment">
              <code>match</code>: Enthält u.a. die Parameter aus dem Pfad (
              <code>match.params.xyz</code>)</li>
            <li class="fragment">
              <code>history</code>: Zum Arbeiten mit der History (z.B.
              <code>push()</code> zum Navigieren)</li>
            <li class="fragment">
              <code>location</code>: Der aktuelle Pfad (z.B.
              <code>pathname</code>,
              <code>search</code>)</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  const HelloComponent = ({match, history, location}) => (
    &lt;div>
      &lt;h1>Hello, {match.params.name}&lt;/h1>
      &lt;small>The current path is: {location.pathname}&lt;/small>
      &lt;button onClick={() =&gt; history.push('/greetings')}>Show Greetings&lt;/button>
    &lt;/div>
  );
  
  // ...
  &lt;Route path="/greet/:name" component={HelloComponent}/>
  
          </code></pre>
          <ul>
            <li class="fragment">Die Properties werden auch an die
              <code>render</code>-Funktion einer
              <code>Route</code> als Parameter übergeben
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
   &lt;Route path="/somewhere" render={({match, history, location}) => . . . }/>
            
                    </code></pre>
        </section>
  
        <section>
          <h3>Links</h3>
          <p>Mit
            <code>Link</code> und
            <code>NavLink</code> können Links erzeugt werden</p>
          <ul>
            <li>Mit
              <code>to</code> wird das Ziel angegeben</li>
            <li>Gerendert wird per default ein
              <code>a</code> Element</li>
            <li>URL wird entsprechend der History (Browser oder Hash) erzeugt</li>
            <li>Mit
              <code>activeClassName</code> und
              <code>activeStyle</code> auf
              <code>NavLink</code> können Styles übergeben werden, die angewendet werden, wenn der Link der aktiven Route entspricht
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import {Link, NavLink} from "react-router-dom";
  
  &lt;Link to='/greetings'>Show all greetings&lt;/Link>
  
  // Erzeugtes 'a' Element erhält 'highlight' CSS-Klasse, wenn die aktive Route
  &lt;NavLink to='/greeting/me' activeClassName="highlight">Greet me&lt;/NavLink>
  
          </code></pre>
        </section>
  
        <section>
          <h3>Das history-Objekt</h3>
          <p class="fragment">Mit dem
            <code>history</code>-Objekt kann mit der Browser History interagiert werden</p>
          <p class="fragment">Es gibt verschiende Implementierungen (insb BrowserHistory und HashHistory sowie "memory history" für Testen)</p>
          <p class="fragment">Mit der History kann auf andere URLs gesprungen werden oder die Location abgefragt werden</p>
          <p class="fragment">Route-Komponenten erhalten die history automatisch per Property</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  function GreetingController({history}) {
    // gehe zu neuer URL
    history.push("/..."); 
  
    // gehe zu neuer URL, lösche aber aktuelle aus History im Browser
    history.replace("/...") 
  
    // aktuelle URL
    const currentPath = history.location.pathname; 
  }
          </code></pre>
        </section>
  
        </section>
  
        <section>
          <h3>Zugriff auf die history außerhalb von "Route Components"</h3>
          <ul>
            <li class="fragment">Komponenten, die von
              <code>Route</code> gerendert werden, erhalten automatisch Zugriff auf
              <code>history</code> etc</li>
            <li class="fragment">Für alle anderen Komponenten, brauchen wir eine andere Lösung</li>
            <li class="fragment">
              <code>withRouter</code> HOC "erweitert" Komponenten und Router Properties</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import {withRouter} from "react-router-dom";
  
  function GreetLink(props) {
    const greeting = this.props.greeting; // übergeben vom ursprünglichen Aufrufer
    const history = this.props.history; // übergeben von withRouter
    return &lt;div>
      &lt;button onClick={() =&gt; history.push(`/${greeting.id}`)}>Show Greeting&lt;/button>
    &lt;/div>;
  }
  
  // 
  export default withRouter(GreetingLink);
                    </code></pre>
        </section>
        <section>
          <h3>withRouter zur Laufzeit</h3>
          <img src="./images/screenshot-withRouter.png" />
        </section>
  
        <section>
          <h3>Hintergrund</h3>
          <h2>Higher-Order Components (HOC)</h2>
          <p>https://reactjs.org/docs/higher-order-components.html</p>
          <p>Eine Higher-Order Komponente ist eine Funktion, die
            <b>eine Komponente entgegennimmt und eine neue Komponente zurückliefert</b>
          </p>
          <p class="fragment">Die Higher-Order-Kommponente ist für das
            <b>rendern</b> der ursprünglichen Komonente verantwortlich
            <ul class="fragment">
              <li>Sie kann das Rendern bei Bedarf auch unterdrücken oder verzögern</li>
              <li>Sie hat Zugriff auf alle ursprünglichen Properties</li>
              <li>Sie kann der Ziel-Komponente zusätzliche Properties übergeben oder welche entfernen</li>
            </ul>
          </p>
  
        </section>
        <section>
          <h3>Beispiel: Higher-Order Components (HOC)</h3>
          <p>Ziel:
            <em>Eine HOC, die ein Greeting lädt das geladene Greeting an die ursprüngliche Komponente weitergibt</em>
          </p>
          <div style="font-size:85%">
            <p>Vorteile:
              <ul>
                <li>"Komplexe" Logik zum Laden der Daten, Fehlerbehandlung etc, liegt zentral in der HOC</li>
                <li>Die gewrappte Komponente muss sich nicht um das (technische) Laden kümmern</li>
                <li>Die gewrappte Komponente benötigt keinen Lifecycle, sie wird nur dargestellt, wenn ein Greeting vorhanden ist</li>
              </ul>
            </p>
          </div>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    
  // GreetingDisplayController.js          
  // GreetingDisplayController (stellt einen Gruß dar):
  function GreetingDisplayController({greeting}) {
    return &lt;h1>&lt;{greeting.name}, {greeting.greeting}&lt;/h1>;
  }
    
  // umschliessen mit der HOC
  export default withGreeting(GreetingDisplayContainer);
  </code></pre>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  // Verwender
  import GreetingDisplayController from "...";
  // dass es sich um eine HOC handelt, ist für den Verwender transparent:
  &lt;GreetingDisplayController greetingId={3} />
                                    </code></pre>
        </section>
        <section>
          <h3>Beispiel: Higher-Order Components (HOC)</h2>
            <p>Schritt 1: HOC definieren</p>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    
    // Schritt 1: stumpfes Wrappen einer Komponente.
    function withGreeting(RawComponent) {
      return class extends React.Component {
        render() {
          // mit {...this.props} werden alle Properties, die der HOC übergeben
          // wurden,  an die Ziel-Komponente übergeben
          return &lt;RawComponent {...this.props} />
        }
      }
                                    </code></pre>
        </section>
        <section>
          <h3>Beispiel: Higher-Order Components (HOC)</h2>
            <p>Schritt 2: Lifecycle-Methoden ("fachliche" Logik der HOC) implementieren</p>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  function withGreeting(RawComponent) {
    return class extends React.Component {
    
      // HOC ist "normale" Komponente, dh wir habe Lifecycle-Methoden etc
      componentDidMount() {
        // GreetingId kommt aus den Props, mit dem die HOC aufgerufen wurde
        const greeting = loadGreeting(this.props.greetingId);
        this.setState({greeting});
      }
  
      componentWillReceiveProps(nextProps) {
        // analog: greeting lesen und State setzen
      }
    
      render() { . . . }
    }
  }
                                      </code></pre>
        </section>
        <section>
          <h3>Beispiel: Higher-Order Components (HOC)</h2>
            <p>Schritt 3: Implementieren der render-Methode</p>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    function withGreeting(RawComponent) {
      return class extends React.Component {
      
        componentDidMount() { ... }
    
        componentWillReceiveProps(nextProps) { ... }
          // analog: greeting lesen und State setzen
        }
      
        render() { 
          if (!this.state.greeting) {
            // Greeting noch nicht geladen
            return null;  
            // alternativ: Loading Spinner zeigen, Fehlerbehandlung o.ä.
          }
  
          // Ziel-Komponente erhält geladenes Greeting als
          // 'greeting' Property
          return &lt;RawComponent greeting={this.state.greeting} />
        }
      }
    }
                                        </code></pre>
        </section>
        <section>
          <h3>Beispiel: Higher-Order Components (HOC)</h2>
            <p>Schritt 4: Verwenden der HOC</p>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import withGreeting from ". . .";
  
  // GreetingDisplayController kennt kein greetingId-Property, 
  // nur das geladene Greeting
  function GreetingDisplayController({greeting}) { . . .};
  
  export default withGreeting(GreetingDisplayController);
                                          </code></pre>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import GreetingDisplayController from ". . .";
  
  // Verwender übergibt nur das greetingId-Property, 
  // nicht das geladene Greeting
  &lt;GreetingDisplayController greetingId={7} />
                                          </code></pre>
        </section>
        <section>
          <h2>Alternative PropTypes</h2>
          <p>https://reactjs.org/docs/render-props.html</p>
          <p>https://www.youtube.com/watch?v=BcVAq3YFiuc</p>
        </section>
  
        <section>
          <h2>Der Router mit TypeScript</h2>
        </section>
  
        <section>
          <h3>RouteComponentProps</h3>
          <p>Der Router übergibt Properties an eine Route-Komponente</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  // GreetingController erhält history etc als Property          
  &lt;Route component={GreetingController} />
                                                      </code></pre>
          <p class="fragment">Die Route-Properties sind im Interface
            <code>RouteComponentProps</code> definiert</p>
          <p class="fragment">Die Komponente kann für ihre Properties das Interface erweitern:</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import { RouteComponentProps } from "react-router";
  interface GreetingControllerProps extends RouteComponentProps&lt;void&gt { 
    // ggf. eigene Properties des GreetingControllers
  }
  class GreetingController extends React.Component&lt;GreetingControllerProps> {
    render() {
      const history = this.props.history; // ok, kein Compile-Fehler
    }
  }
  </code></pre>
        </section>
        <section>
          <h3>RouteComponentProps #2</h3>
          <p>Der Router übergibt die Parameter aus der URL an die Route-Komponente</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    // GreetingController erhält "greetingId" als Property
    &lt;Route path="/greeting/:greetingId" component={GreetingController} />
                                                        </code></pre>
          <p class="fragment">RouteComponentProps ist mit den erwarteten Parametern aus der URL generifiziert
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import { RouteComponentProps } from "react-router";
  
  // Die im Path definierten Parameter
  interface GreetingControllerParams { greetingId: string };
  
  // Als Type-Argument werden die Parameter angegeben
  interface GreetingControllerProps extends 
    RouteComponentProps&lt;GreetingControllerParams&gt {   }
  
  class GreetingController extends React.Component&lt;GreetingControllerProps> {
    render() {
      const params = this.props.match;
  
      const greetingId = params.greetingId; // ok, kein Compile-Fehler
      const userId = params.userId; // Fehler: userId nicht bekannt
    }
  }
    </code></pre>
        </section>
  

      <section id="t7">
        <h1>Zustands-Management mit Redux</h1>
    </section>

    <section>
      <h2>Eine typische React-Anwendung in Komponenten</h2>
      <h3>Frage an Euch: was könnte es für Probleme geben?</h3>
      <img src="images/typische-react-komponenten-hierarchie.png"  style="border:0;box-shadow:0 0 0 0;height:650px"  />
    </section>

    <section>
        <h3>Problem 1: Über Komponenten verteilter Zustand</h2>
        <img src="images/verteilter-zustand.png"  style="border:0;box-shadow:0 0 0 0;height:650px" />
        <p>Wo muss ich nach Fehlern suchen? Wo ist die Logik?</p>
    </section>

    <section>
      <h3>Problem 2: Getrennte Komponentenhierarchien</h2>
      <img src="images/zwei-komponenten-hierarchien.png" style="border:0;box-shadow:0 0 0 0;height:650px"  />
      <p>Geht entweder nicht oder "Gott-Komponente" entsteht</p>
  </section>

  <section>
    <h3>Problem 3: Gemeinsamer ("globaler") Zustand</h2>
    <img src="images/gemeinsam-genutzter-state.png"  style="border:0;box-shadow:0 0 0 0;height:650px" />
    <p>Wie kommt Zustand von ganz oben nach ganz unten?</p>
</section>

<section>
  <h3>Problem 4: UI und Logik vermischt</h2>
  <img src="images/ui-und-logic-vermischt.png"  style="border:0;box-shadow:0 0 0 0;height:650px" />
  <p>Wiederverwendung? React-unabhängigkeit? Testbarkeit?</p>
</section>

<section>
  <h2>Lösung ?!</h2>
  <h3>External Statemanagement</h3>
  <div  class="fragment">
  <p>Habt ihr Ideen?</p>
  <p>Wie können wir Zustand und/oder Logik aus den Komponenten befreien?</p></div>
</section>


<section>
  <h3>Wiederholung</h3>
    <h2>Render Cycle in Pure React</h2>
    <img src="images/redux-01-react-cycle-no-redux.png"  style="border:0;box-shadow:0 0 0 0;height:650px"/>
</section>

<section>
  <h3>Hintergrund</h3>
  <h2>Flux-Architektur</h2>
  <img src="images/flux-simple.png"  style="border:0;box-shadow:0 0 0 0;height:550px" />
  <p>Idee: Uni-directional dataflow</p>
</section>



<section>
    <h3>External Statemanagement</h3>
  <h2>Redux</h2>
  <div class="fragment">
    <ul>
      <li class="fragment">inspiriert von Flux-Idee</li>
      <li class="fragment">viele funktionale Paradigmen</li>
      <li class="fragment">React unabhängig (mittlerweile auch für Angular und Vue)</li>
    </ul>
</section>

    <section>
        <h2>Redux extrahiert die Verantwortlichkeiten</h2>
        <img src="images/redux-02-extracting-responsibility.png" style="border:0;box-shadow:0 0 0 0;width: 900px"/>
    </section>
    <section>
        <h2>Demo: Redux & Redux Devtools</h2>
        <a href="code/schritte/redux/7-redux-complete-app/public/index.html" target="_blank">Ziel-Anwendung</a>
    </section>

    <section>
        <h2>Redux Schritt-für-Schritt</h2>
        <p>Wir stellen eine Komponente auf Redux um</p>
        <p>(Verzeichnis: <code>workspace-redux</code>)</p>
    </section>

    <section>
        <h2>Strukturierter Überblick über alle Redux Teile</h2>
    </section>

    <section>
        <h3>Event-Handlers werden Action-Creators</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export const setFilter = filter => {
return {
    type: SET_FILTER,
    filter
};
}
</code></pre>
        <ul>
            <li class="fragment">Action-Creators erzeugen Action-Objekte</li>
            <li class="fragment">Actions sind Kommando-artige Strukturen von Dingen, die die Applikation tun soll
            <li class="fragment">Über die dispatch-Methode des Stores werden sie an <em>alle</em> Reducer weiter gegeben
            <li class="fragment">Actions bestehen aus einem Typen und einer beliebigen Nutzlast (payload)</li>
        </ul>
    </section>

    <section>
        <h3>Action-Creators machen Server-Calls</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export const loadGreeting = greetingId => dispatch => {
fetch(BACKEND_URL+'/'+greetingId)
    .then(response => response.json())
    .then(greetings => dispatch({
        type: SET_GREETINGS,
        greetings
    });
};
</code></pre>
        <ul>
            <li class="fragment">Die Action wird nicht direkt zurück geliefert, sondern erst später dispatched</li>
            <li class="fragment">wir bekommen die dispatch Methode als Parameter, mit der wir später
                die Action dispatchen</li>
        </ul>
        <p  class="fragment"><strong>Action-Creators sind die einzigen Teile einer Redux-Anwendung, die asynchrone Operationen
            ausführen dürfen</strong></p>
    </section>

    <section>
        <h3>Ein <em>einziger</em> Store hält den <em>kompletten</em> Zustand</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { Provider } from 'react-redux';
import { createStore } from 'redux';
import { rootReducer } from './reducers';

// http://redux.js.org/docs/api/createStore.html
const store = createStore(
rootReducer // reducer
);
ReactDOM.render(
&lt;Provider store={store}>
    &lt;GreetingController />
&lt;/Provider>,
mountNode
);
    </code></pre>
        <ul>
            <li class="fragment">Zentraler Teil der Anwendung
            <li class="fragment">Liefert die bereits bekannte dispatch-Methode
            <li class="fragment">Der Store wird allen Componenten über die Wrapper-Komponenten <em>Provider</em>
                zur Verfügung gestellt
        </ul>
    </section>

    <section>
        <h3>Middleware zwischen Dispatch und Store</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

const store = createStore(
rootReducer, // reducer
applyMiddleware(thunk) // middleware as enhancer
);
    </code></pre>
        <ul>
            <li class="fragment">Die Thunk Middleware dient als de-facto-Standard</li>
            <li class="fragment">Gibt die dispatch-Methode and (asynchrone) Action Creators weiter
            <li class="fragment"><a href="https://github.com/gaearon/redux-thunk#whats-a-thunk" target="_blank">
                'A thunk is a function that wraps an expression to delay its evaluation'
            </a></li>
            <li class="fragment">Middleware ist ein fortgeschrittenes Feature und meistens genügt die Thunk Middleware</li>
        </ul>
    </section>

    <section>
        <h3>Reducers enthalten die Kern-(Business)-Logik</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import {combineReducers} from 'redux';

// http://redux.js.org/docs/api/combineReducers.html
export const rootReducer = combineReducers({
greetings, // updates greeting partial state
filter,
mode
});
    </code></pre>
        <ul>
            <li class="fragment">Reducer sind pure Funtionen, die den alten Zustand und eine Action bekommen und einen neuen Zustand erzeugen
            <li class="fragment">Oft bearbeitet ein Reducer nur einen Teil des Zustands
        </ul>
    </section>

    <section>
        <h3>Teil-Reducer</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
const mode = (state = MODE_MASTER, action) => {
switch (action.type) {
    case SET_MODE:
        return action.mode;
    default:
        return state;
}
};
    </code></pre>
        <ul>
            <li class="fragment">Initialisiert seinen Teilzustand (oft mit einem Default-Parameter)</li>
            <li class="fragment">Ändert niemals zustand direkt</li>
            <li class="fragment">Sondern liefert einen neuen Zustand (manchmal teilweise als Kopie)
        </ul>
    </section>

    <section>
        <h3>Zustand mit Komponenten verbinden</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { connect } from 'react-redux';

import * as actions from './actions';

export default connect(
state => ({
    mode: state.mode
    // ...
}),
actions
)(GreetingController);
        </code></pre>
        <ul>
            <li class="fragment">der Provider gibt den Store in alle Komponenten</li>
            <li class="fragment">Die Connect-Funktion extrahiert daraus Zustand, der als Property an Komponenten übergeben wird
            <li class="fragment">Action-Creators können ebenso in Komponent gegeben werden</li>
        </ul>
    </section>

    <section>
        <h3>Verwendung von Zustand und Action-Creators in verbundenen Komponenten</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class GreetingController extends React.Component {
render() {
    // state from store
    const {aggregatedGreetings, greetings, mode} = this.props;
    // action creators bound to dispatch from store
    const {setMode, saveGreeting, setFilter} = this.props;

    // ...
}
}
        </code></pre>
        <ul>
            <li class="fragment">Action-Creators und Zustand werden in Properties hinein gemerged
            <li class="fragment">Diese werden mit ES6-Destructuring an den Stellen aufgelöst wo wir sie brauchen
            <li class="fragment">Die Komponenten wird nur neu gerendert wenn sich der benutzte Zustand verändert</li>
        </ul>
    </section>

    <section>
        <h3>Selektoren</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export const selectGreetings = ({greetings}) => greetings;

export default connect(
state => ({
    greetings: selectGreetings(state),
    // ...
}),
// ...
)(GreetingController);        </code></pre>
        <ul>
            <li class="fragment">Berechnen abgeleiteten Zustand</li>
            <li class="fragment">Oft in einer eigener Datei</li>
            <li class="fragment">Erlauben Wiederbenutzung und Caching (normalerweise
                <a href="http://redux.js.org/docs/recipes/ComputingDerivedData.html" target="_blank">reselect</a>)</li>
        </ul>
    </section>

    <section>
        <h2>Zusammenfassung Redux-Architektur</h2>
        <img src="images/redux-03-resulting-redux-architecture.png" style="border:0;box-shadow:0 0 0 0;max-height:650px" />
    </section>

    <section>
        <h3>Lokaler State ist weiterhin erlaubt!</h3>
        <p>Es gibt unterschiedliche Arten von "State"</p>

        <img src="images/three-kinds-of-state.png"  style="border:0;box-shadow:0 0 0 0;max-height:650px" />
        
      </section>
    
      <section>
        <h2>Geschafft ;-)</h2>
        <h3>Vielen Dank für Eure Teilnahme!</h3>
        <p>Kontakt: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a> | <a href="https://xing.to/nilshartmann" target="_blank">Xing</a> | <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a></p>
      </section>


    </div>

  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>
  <script src="lib/jquery-2.2.4.js"></script>

  <script>
    Reveal.addEventListener('ready', function (event) {
      if (window.location.hostname.indexOf('localhost') !== -1) {
        // only applies to presentation version
        Reveal.configure({ controls: false });
      } else {
        // only applies to public version
        //            $('.fragment').removeClass('fragment');
      }
      // applies to all versions
      // $('code').removeClass('line-numbers');
      //        $('.fragment').removeClass('fragment');
    });
  </script>


  <script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      width: '100%',
      height: '100%',

      transition: 'slide', // none/fade/slide/convex/concave/zoom

      // Optional reveal.js plugins
      dependencies: [
        {
          src: 'reveal.js/lib/js/classList.js', condition: function () {
            return !document.body.classList;
          }
        },
        {
          src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
            return !!document.querySelector('[data-markdown]');
          }
        },
        {
          src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
            return !!document.querySelector('[data-markdown]');
          }
        },
        {
          src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
            return !!document.querySelector('pre code');
          }, callback: function () {
            hljs.initHighlightingOnLoad();
          }
        },
        { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
        { src: 'reveal.js/plugin/notes/notes.js', async: true },
        { src: 'lib/js/line-numbers.js' }
      ]
    });

  </script>

</body>

</html>